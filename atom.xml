<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title><![CDATA[Think²º¹¹]]></title>
  <subtitle><![CDATA[当思维和视野不再被日常熟悉的事情所局限时，就能发现更大的世界。Stay Hungry, Stay Foolish.]]></subtitle>
  <link href="/atom.xml" rel="self"/>
  <link href="http://think2011.github.io/"/>
  <updated>2015-12-16T08:47:32.677Z</updated>
  <id>http://think2011.github.io/</id>
  
  <author>
    <name><![CDATA[曾浩]]></name>
    <email><![CDATA[452125301@qq.com]]></email>
  </author>
  
  <generator uri="http://zespia.tw/hexo/">Hexo</generator>
  
  <entry>
    <title><![CDATA[用中文编写javascript代码]]></title>
    <link href="http://think2011.github.io/2015/11/19/calculate-legs/"/>
    <id>http://think2011.github.io/2015/11/19/calculate-legs/</id>
    <published>2015-11-19T06:00:03.000Z</published>
    <updated>2015-11-19T06:34:06.000Z</updated>
    <content type="html"><![CDATA[<p><img src="http://think2011.qiniudn.com/calculate-legs.png" alt=""></p>
<p>群里有人出了道题，问能不能用javascript来计算。<br>用递归可以很方便的解决这个问题，可是要写不少命名，那么能不能用中文来写javascript呢。</p>
<a id="more"></a>
<figure class="highlight js"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
</pre></td><td class="code"><pre><span class="keyword">var</span> 人  = {数量: <span class="number">5</span>, 腿: <span class="number">2</span>},
    大猫 = {数量: <span class="number">5</span>, 腿: <span class="number">4</span>},
    小猫 = {数量: <span class="number">5</span>, 腿: <span class="number">4</span>},
    鼠  = {数量: <span class="number">5</span>, 腿: <span class="number">4</span>};

<span class="keyword">var</span> 算腿 = <span class="function"><span class="keyword">function</span> <span class="params">(谁, 带的那谁)</span> {</span>
    <span class="keyword">var</span> 腿    = <span class="number">0</span>,
        谁的数量 = 谁.数量;

    <span class="keyword">while</span> (谁的数量 &gt;= <span class="number">1</span>) {
        腿 += 谁.腿;

        <span class="comment">// 如果有[带的那谁],就递归</span>
        <span class="keyword">if</span> (带的那谁) {
            腿 += 算腿(带的那谁);
        }

        谁的数量 -= <span class="number">1</span>;
    }

    <span class="keyword">return</span> 腿;
};

<span class="keyword">var</span> 到底TM有多少条腿 = <span class="function"><span class="keyword">function</span> <span class="params">(所有的东西)</span> {</span>
    <span class="keyword">var</span> 腿 = <span class="number">0</span>;

    腿 += 算腿(所有的东西[<span class="number">0</span>], 所有的东西[<span class="number">1</span>]);

    <span class="comment">// [谁]和[带的那谁]的计算完了,下一个</span>
    所有的东西.shift();

    <span class="comment">// 如果还有东西,就递归</span>
    <span class="keyword">if</span> (所有的东西.length &gt;= <span class="number">2</span>) {
        腿 += 到底TM有多少条腿(所有的东西);
    }

    <span class="keyword">return</span> 腿;
};

到底TM有多少条腿([人, 大猫, 小猫, 鼠]);

<span class="comment">// 有人说少算了个腿,那 🐴 = {数量: 1, 腿: 4}</span>
</pre></td></tr></table></figure>

<p>看起来用中文描述挺方便的（想起了易语言），只是.. 🙊</p>
]]></content>
    <summary type="html">
    <![CDATA[<p><img src="http://think2011.qiniudn.com/calculate-legs.png" alt=""></p>
<p>群里有人出了道题，问能不能用javascript来计算。<br>用递归可以很方便的解决这个问题，可是要写不少命名，那么能不能用中文来写javascript呢。</p>
]]>
    
    </summary>
    
      <category term="javascript" scheme="http://think2011.github.io/tags/javascript/"/>
    
      <category term="中文" scheme="http://think2011.github.io/tags/%E4%B8%AD%E6%96%87/"/>
    
      <category term="作品" scheme="http://think2011.github.io/categories/%E4%BD%9C%E5%93%81/"/>
    
      <category term="js" scheme="http://think2011.github.io/categories/%E4%BD%9C%E5%93%81/js/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[体验异步的终极解决方案-ES7的Async/Await]]></title>
    <link href="http://think2011.github.io/2015/11/09/ES7-Async-Await/"/>
    <id>http://think2011.github.io/2015/11/09/ES7-Async-Await/</id>
    <published>2015-11-09T14:44:07.000Z</published>
    <updated>2015-11-19T06:28:09.000Z</updated>
    <content type="html"><![CDATA[<blockquote>
<p>阅读本文前，期待您对promise和ES6(ECMA2015)有所了解，会更容易理解。<br>本文以体验为主，不会深入说明，结尾有详细的文章引用。</p>
</blockquote>
<h2 id="第一个例子">第一个例子</h2>
<p>Async/Await应该是目前最简单的异步方案了，首先来看个例子。</p>
<p>这里我们要实现一个暂停功能，输入N毫秒，则停顿N毫秒后才继续往下执行。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
</pre></td><td class="code"><pre><span class="keyword">var</span> sleep = <span class="function"><span class="keyword">function</span> <span class="params">(time)</span> {</span>
    <span class="keyword">return</span> <span class="keyword">new</span> Promise(<span class="function"><span class="keyword">function</span> <span class="params">(resolve, reject)</span> {</span>
        setTimeout(<span class="function"><span class="keyword">function</span> <span class="params">()</span> {</span>
            resolve();
        }, time);
    })
};

<span class="keyword">var</span> start = async <span class="function"><span class="keyword">function</span> <span class="params">()</span> {</span>
    <span class="comment">// 在这里使用起来就像同步代码那样直观</span>
    console.log(<span class="string">'start'</span>);
    await sleep(<span class="number">3000</span>);
    console.log(<span class="string">'end'</span>);
};

start();
</pre></td></tr></table></figure>

<p>控制台先输出<code>start</code>，稍等<code>3秒</code>后，输出了<code>end</code>。</p>
<h2 id="基本规则">基本规则</h2>
<ol>
<li><p>async 表示<code>这是一个async函数</code>，<code>await只能用在这个函数里面</code>。</p>
</li>
<li><p>await 表示在这里<code>等待promise返回结果</code>了，再继续执行。</p>
</li>
<li><p>await 后面跟着的<code>应该是一个promise对象</code>（当然，其他返回值也没关系，只是会立即执行，不过那样就没有意义了..）</p>
</li>
</ol>
<a id="more"></a>
<h2 id="获得返回值">获得返回值</h2>
<p>await等待的虽然是promise对象，但不必写<code>.then(..)</code>，直接可以得到返回值。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
9
10
11
12
13
</pre></td><td class="code"><pre><span class="keyword">var</span> sleep = <span class="function"><span class="keyword">function</span> <span class="params">(time)</span> {</span>
    <span class="keyword">return</span> <span class="keyword">new</span> Promise(<span class="function"><span class="keyword">function</span> <span class="params">(resolve, reject)</span> {</span>
        setTimeout(<span class="function"><span class="keyword">function</span> <span class="params">()</span> {</span>
            <span class="comment">// 返回 ‘ok’</span>
            resolve(<span class="string">'ok'</span>);
        }, time);
    })
};

<span class="keyword">var</span> start = async <span class="function"><span class="keyword">function</span> <span class="params">()</span> {</span>
    <span class="keyword">let</span> result = await sleep(<span class="number">3000</span>);
    console.log(result); <span class="comment">// 收到 ‘ok’</span>
};
</pre></td></tr></table></figure>

<h2 id="捕捉错误">捕捉错误</h2>
<p>既然<code>.then(..)</code>不用写了，那么<code>.catch(..)</code>也不用写，可以直接用标准的<code>try catch</code>语法捕捉错误。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
</pre></td><td class="code"><pre><span class="keyword">var</span> sleep = <span class="function"><span class="keyword">function</span> <span class="params">(time)</span> {</span>
    <span class="keyword">return</span> <span class="keyword">new</span> Promise(<span class="function"><span class="keyword">function</span> <span class="params">(resolve, reject)</span> {</span>
        setTimeout(<span class="function"><span class="keyword">function</span> <span class="params">()</span> {</span>
            <span class="comment">// 模拟出错了，返回 ‘error’</span>
            reject(<span class="string">'error'</span>);
        }, time);
    })
};

<span class="keyword">var</span> start = async <span class="function"><span class="keyword">function</span> <span class="params">()</span> {</span>
    <span class="keyword">try</span> {
        console.log(<span class="string">'start'</span>);
        await sleep(<span class="number">3000</span>); <span class="comment">// 这里得到了一个返回错误</span>
        
        <span class="comment">// 所以以下代码不会被执行了</span>
        console.log(<span class="string">'end'</span>);
    } <span class="keyword">catch</span> (err) {
        console.log(err); <span class="comment">// 这里捕捉到错误 `error`</span>
    }
};
</pre></td></tr></table></figure>

<h2 id="循环多个await">循环多个await</h2>
<p>await看起来就像是同步代码，所以可以理所当然的写在<code>for</code>循环里，不必担心以往需要<code>闭包</code>才能解决的问题。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
</pre></td><td class="code"><pre>..省略以上代码

<span class="keyword">var</span> start = async <span class="function"><span class="keyword">function</span> <span class="params">()</span> {</span>
    <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">1</span>; i &lt;= <span class="number">10</span>; i++) {
        console.log(`当前是第${i}次等待..`);
        await sleep(<span class="number">1000</span>);
    }
};
</pre></td></tr></table></figure>

<p>值得注意的是，<code>await</code>必须在<code>async函数的上下文中</code>的。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
</pre></td><td class="code"><pre>..省略以上代码

<span class="keyword">let</span> 一到十 = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>,<span class="number">8</span>,<span class="number">9</span>,<span class="number">10</span>];

<span class="comment">// 错误示范</span>
一到十.forEach(<span class="function"><span class="keyword">function</span> <span class="params">(v)</span> {</span>
    console.log(`当前是第${v}次等待..`);
    await sleep(<span class="number">1000</span>); <span class="comment">// 错误!! await只能在async函数中运行</span>
});

<span class="comment">// 正确示范</span>
<span class="keyword">for</span>(<span class="keyword">var</span> v of 一到十) {
    console.log(`当前是第${v}次等待..`);
    await sleep(<span class="number">1000</span>); <span class="comment">// 正确, for循环的上下文还在async函数中</span>
}
</pre></td></tr></table></figure>

<h2 id="第二个例子">第二个例子</h2>
<p>这个例子是一个小应用，根据电影文件名，自动下载对应的海报。</p>
<p><img src="https://raw.github.com/think2011/ES7-Async-Await-Demo/master/app-demo.gif" alt=""></p>
<p>直接贴出代码，就不说明了。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
48
</pre></td><td class="code"><pre>import fs from <span class="string">'fs'</span>;
import path from <span class="string">'path'</span>;
import request from <span class="string">'request'</span>;

<span class="keyword">var</span> movieDir = __dirname + <span class="string">'/movies'</span>,
    exts     = [<span class="string">'.mkv'</span>, <span class="string">'.avi'</span>, <span class="string">'.mp4'</span>, <span class="string">'.rm'</span>, <span class="string">'.rmvb'</span>, <span class="string">'.wmv'</span>];

<span class="comment">// 读取文件列表</span>
<span class="keyword">var</span> readFiles = <span class="function"><span class="keyword">function</span> <span class="params">()</span> {</span>
    <span class="keyword">return</span> <span class="keyword">new</span> Promise(<span class="function"><span class="keyword">function</span> <span class="params">(resolve, reject)</span> {</span>
        fs.readdir(movieDir, <span class="function"><span class="keyword">function</span> <span class="params">(err, files)</span> {</span>
            resolve(files.filter((v) =&gt; exts.includes(path.parse(v).ext)));
        });
    });
};

<span class="comment">// 获取海报</span>
<span class="keyword">var</span> getPoster = <span class="function"><span class="keyword">function</span> <span class="params">(movieName)</span> {</span>
    <span class="keyword">let</span> url = `https:<span class="comment">//api.douban.com/v2/movie/search?q=${encodeURI(movieName)}`;</span>

    <span class="keyword">return</span> <span class="keyword">new</span> Promise(<span class="function"><span class="keyword">function</span> <span class="params">(resolve, reject)</span> {</span>
        request({url: url, json: <span class="literal">true</span>}, <span class="function"><span class="keyword">function</span> <span class="params">(error, response, body)</span> {</span>
            <span class="keyword">if</span> (error) <span class="keyword">return</span> reject(error);

            resolve(body.subjects[<span class="number">0</span>].images.large);
        })
    });
};

<span class="comment">// 保存海报</span>
<span class="keyword">var</span> savePoster = <span class="function"><span class="keyword">function</span> <span class="params">(movieName, url)</span> {</span>
    request.get(url).pipe(fs.createWriteStream(path.join(movieDir, movieName + <span class="string">'.jpg'</span>)));
};


(async () =&gt; {
    <span class="keyword">let</span> files = await readFiles();

    <span class="comment">// await只能使用在原生语法</span>
    <span class="keyword">for</span> (<span class="keyword">var</span> file of files) {
        <span class="keyword">let</span> name = path.parse(file).name;

        console.log(`正在获取【${name}】的海报`);
        savePoster(name, await getPoster(name));
    }

    console.log(<span class="string">'=== 获取海报完成 ==='</span>);
})();
</pre></td></tr></table></figure>

<h2 id="其他信息">其他信息</h2>
<p>微软的Edge浏览器已经率先支持了async/await语法，相信不久之后chrome等浏览器、node.js也会跟进的，超期待！~(≧▽≦)/~</p>
<h2 id="一些资料和工具">一些资料和工具</h2>
<ul>
<li><a href="https://github.com/think2011/ES7-Async-Await-Demo" target="_blank" rel="external">文中讲到的例子的源代码 https://github.com/think2011/ES7-Async-Await-Demo</a></li>
<li><a href="https://babeljs.io/repl/" target="_blank" rel="external">方便的在线babel运行环境 https://babeljs.io/repl/</a></li>
<li><a href="http://es6.ruanyifeng.com/#docs/async" target="_blank" rel="external">很详细的异步编程教程 http://es6.ruanyifeng.com/#docs/async</a></li>
<li><a href="http://liubin.github.io/promises-book/#introduction" target="_blank" rel="external">很详细的promise小书 http://liubin.github.io/promises-book/#introduction</a></li>
</ul>
<blockquote>
<p>本文同时发布在 <a href="http://think2011.github.io/2015/11/09/ES7-Async-Await/" target="_blank" rel="external">think2011的博客</a> 2015-11-09 22:42</p>
</blockquote>
]]></content>
    <summary type="html">
    <![CDATA[<blockquote>
<p>阅读本文前，期待您对promise和ES6(ECMA2015)有所了解，会更容易理解。<br>本文以体验为主，不会深入说明，结尾有详细的文章引用。</p>
</blockquote>
<h2 id="第一个例子">第一个例子</h2>
<p>Async/Await应该是目前最简单的异步方案了，首先来看个例子。</p>
<p>这里我们要实现一个暂停功能，输入N毫秒，则停顿N毫秒后才继续往下执行。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
</pre></td><td class="code"><pre><span class="keyword">var</span> sleep = <span class="function"><span class="keyword">function</span> <span class="params">(time)</span> {</span>
    <span class="keyword">return</span> <span class="keyword">new</span> Promise(<span class="function"><span class="keyword">function</span> <span class="params">(resolve, reject)</span> {</span>
        setTimeout(<span class="function"><span class="keyword">function</span> <span class="params">()</span> {</span>
            resolve();
        }, time);
    })
};

<span class="keyword">var</span> start = async <span class="function"><span class="keyword">function</span> <span class="params">()</span> {</span>
    <span class="comment">// 在这里使用起来就像同步代码那样直观</span>
    console.log(<span class="string">'start'</span>);
    await sleep(<span class="number">3000</span>);
    console.log(<span class="string">'end'</span>);
};

start();
</pre></td></tr></table></figure>

<p>控制台先输出<code>start</code>，稍等<code>3秒</code>后，输出了<code>end</code>。</p>
<h2 id="基本规则">基本规则</h2>
<ol>
<li><p>async 表示<code>这是一个async函数</code>，<code>await只能用在这个函数里面</code>。</p>
</li>
<li><p>await 表示在这里<code>等待promise返回结果</code>了，再继续执行。</p>
</li>
<li><p>await 后面跟着的<code>应该是一个promise对象</code>（当然，其他返回值也没关系，只是会立即执行，不过那样就没有意义了..）</p>
</li>
</ol>
]]>
    
    </summary>
    
      <category term="javascript" scheme="http://think2011.github.io/tags/javascript/"/>
    
      <category term="node.js" scheme="http://think2011.github.io/tags/nodejs/"/>
    
      <category term="ES7" scheme="http://think2011.github.io/tags/ES7/"/>
    
      <category term="async" scheme="http://think2011.github.io/tags/async/"/>
    
      <category term="await" scheme="http://think2011.github.io/tags/await/"/>
    
      <category term="作品" scheme="http://think2011.github.io/categories/%E4%BD%9C%E5%93%81/"/>
    
      <category term="js" scheme="http://think2011.github.io/categories/%E4%BD%9C%E5%93%81/js/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[localResizeIMG-前端本地客户端压缩图片，兼容IOS，Android，PC、自动按需加载文件]]></title>
    <link href="http://think2011.github.io/2015/08/10/LocalResizeIMG4/"/>
    <id>http://think2011.github.io/2015/08/10/LocalResizeIMG4/</id>
    <published>2015-08-10T05:20:44.000Z</published>
    <updated>2015-11-09T14:52:49.000Z</updated>
    <content type="html"><![CDATA[<h1 id="演示一下">演示一下</h1>
<p><img src="http://think2011.github.io/localResizeIMG/test/demo.gif" alt=""></p>
<h1 id="自己试试">自己试试</h1>
<p><img src="http://think2011.github.io/localResizeIMG/test/qrcode.png" alt=""></p>
<p><a href="http://think2011.github.io/localResizeIMG/test/" target="_blank" rel="external">点我直接进入演示页面</a></p>
<a id="more"></a>
<h1 id="介绍说明">介绍说明</h1>
<p>在前端压缩好要上传的图片可以更快的发送给后端，因此也特别适合在移动设备上使用。</p>
<ul>
<li><p>兼容IOS&amp;Android，修复了IOS和Android某些版本已知的BUG（<code>这也是插件最有意义的存在价值</code>）。</p>
</li>
<li><p>按需加载文件，仅需引入<code>lrz.bundle.js</code>文件，例如当检测是IOS7的用户，那么会自动异步再载入修复BUG的文件，而无需担心浪费宝贵的带宽开销。</p>
</li>
<li><p>原生JS编写，不依赖例如<code>jquery</code>等第三方库。</p>
</li>
</ul>
<h1 id="如何获取">如何获取</h1>
<p>通过以下方式都可以下载：</p>
<ol>
<li>执行<code>npm i lrz</code>（推荐）</li>
<li>或者 <code>git clone</code>本库</li>
<li>要么 在页面右侧点击<code>download zip</code></li>
</ol>
<p>接着在页面中引入</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre>1
</pre></td><td class="code"><pre><span class="tag">&lt;<span class="title">script</span> <span class="attribute">src</span>=<span class="value">"./dist/lrz.bundle.js"</span>&gt;</span><span class="javascript"></span><span class="tag">&lt;/<span class="title">script</span>&gt;</span>
</pre></td></tr></table></figure><br><code>请绝对不要删除【dist】目录下的任何文件，那些是某些情况自动按需载入的文件。</code><br><br># 如何使用<br><br>### 方式1:<br><br>如果您的图片来自用户拍摄或者上传的，您需要一个<code>input file</code>来获取图片。<br><br><figure class="highlight html"><table><tr><td class="gutter"><pre>1
</pre></td><td class="code"><pre><span class="tag">&lt;<span class="title">input</span> <span class="attribute">onchange</span>=<span class="value">"upload()"</span> <span class="attribute">type</span>=<span class="value">"file"</span> <span class="attribute">capture</span>=<span class="value">"camera"</span> /&gt;</span>
</pre></td></tr></table></figure>

<p>接着通过change事件可以得到用户选择的图片</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
9
10
11
12
</pre></td><td class="code"><pre><span class="function"><span class="keyword">function</span> <span class="title">upload</span> <span class="params">()</span> {</span>
    lrz(<span class="keyword">this</span>.files[<span class="number">0</span>])
        .then(<span class="function"><span class="keyword">function</span> <span class="params">(rst)</span> {</span>
            <span class="comment">// 处理成功会执行</span>
        })
        .catch(<span class="function"><span class="keyword">function</span> <span class="params">(err)</span> {</span>
            <span class="comment">// 处理失败会执行</span>
        })
        .always(<span class="function"><span class="keyword">function</span> <span class="params">()</span> {</span>
            <span class="comment">// 不管是成功失败，都会执行</span>
        });
});
</pre></td></tr></table></figure>

<h3 id="方式2：">方式2：</h3>
<p>如果您的图片不是来自用户上传的，那么也可以直接传入图片路径。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
9
10
</pre></td><td class="code"><pre>lrz(<span class="string">'./xxx/xx/x.png'</span>)
        .then(<span class="function"><span class="keyword">function</span> <span class="params">(rst)</span> {</span>
            <span class="comment">// 处理成功会执行</span>
        })
        .catch(<span class="function"><span class="keyword">function</span> <span class="params">(err)</span>{</span>
            <span class="comment">// 处理失败会执行</span>
        })
        .always(<span class="function"><span class="keyword">function</span> <span class="params">()</span> {</span>
            <span class="comment">// 不管是成功失败，都会执行</span>
        });
</pre></td></tr></table></figure>

<h1 id="后端处理">后端处理</h1>
<ul>
<li><p>后端最终会收到前端发送的<code>base64</code>字符串，接着处理字符串为图片即可。</p>
</li>
<li><p>具体请使用关键字<code>base64 转 image 开发语言</code>进行谷歌|百度。</p>
</li>
<li><p>前端生成的结果中有一个<code>base64Len</code>，这是字符串的长度，后端应该核对以确认是否提交完整。</p>
</li>
</ul>
<h1 id="API">API</h1>
<p><a href="https://github.com/think2011/localResizeIMG/wiki" target="_blank" rel="external">具体参数说明请查看WIKI。</a></p>
<h1 id="兼容性">兼容性</h1>
<p>IE9以上及大部分非IE浏览器（chrome、微信什么的）</p>
<h1 id="FAQ">FAQ</h1>
<p><a href="https://github.com/think2011/localResizeIMG/issues" target="_blank" rel="external">有疑问请直接在 issues 中提问 🙈</a></p>
<ul>
<li>Q：有时拍摄完照片后，页面自动刷新或闪退了。</li>
<li><p>A：虽然已作了优化处理，但内存似乎还是爆掉了，常见于低配android手机。</p>
</li>
<li><p>Q: 怎么批量上传图片?</p>
</li>
<li><p>A: 您可以自己写个循环来传入用户多选的图片，但在移动端上请勿这样做，原因同上。</p>
</li>
<li><p>Q: 直接传入图片路径的无法生成图片</p>
</li>
<li><p>A: 可能是跨域的问题，具体请看<a href="https://developer.mozilla.org/en-US/docs/Web/HTML/CORS_enabled_image" target="_blank" rel="external">CORS_enabled_image</a></p>
</li>
<li><p>Q: 想要商用可以吗？</p>
</li>
<li>A: 没问题，但请留意issue里已知的问题。</li>
</ul>
<h1 id="开发">开发</h1>
<p><a href="https://github.com/think2011/localResizeIMG/wiki/%E5%BC%80%E5%8F%91" target="_blank" rel="external">想要参与|定制|了解源码请点击这里</a></p>
<h1 id="感谢">感谢</h1>
<ul>
<li>@dwandw</li>
<li>@yourlin</li>
<li>@wxt2005</li>
</ul>
<p>以上在之前的版本帮忙参与维护的朋友，以及提出问题的朋友们，真的真的很感谢你们。：D</p>
]]></content>
    <summary type="html">
    <![CDATA[<h1 id="演示一下">演示一下</h1>
<p><img src="http://think2011.github.io/localResizeIMG/test/demo.gif" alt=""></p>
<h1 id="自己试试">自己试试</h1>
<p><img src="http://think2011.github.io/localResizeIMG/test/qrcode.png" alt=""></p>
<p><a href="http://think2011.github.io/localResizeIMG/test/" target="_blank" rel="external">点我直接进入演示页面</a></p>
]]>
    
    </summary>
    
      <category term="javascript" scheme="http://think2011.github.io/tags/javascript/"/>
    
      <category term="上传" scheme="http://think2011.github.io/tags/%E4%B8%8A%E4%BC%A0/"/>
    
      <category term="压缩" scheme="http://think2011.github.io/tags/%E5%8E%8B%E7%BC%A9/"/>
    
      <category term="客户端压缩图片" scheme="http://think2011.github.io/tags/%E5%AE%A2%E6%88%B7%E7%AB%AF%E5%8E%8B%E7%BC%A9%E5%9B%BE%E7%89%87/"/>
    
      <category term="LocalResizeIMG" scheme="http://think2011.github.io/tags/LocalResizeIMG/"/>
    
      <category term="作品" scheme="http://think2011.github.io/categories/%E4%BD%9C%E5%93%81/"/>
    
      <category term="js" scheme="http://think2011.github.io/categories/%E4%BD%9C%E5%93%81/js/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[ES6(ECMAScript 6)笔记8-函数的扩展]]></title>
    <link href="http://think2011.github.io/2015/08/07/ES6/ES6-8/"/>
    <id>http://think2011.github.io/2015/08/07/ES6/ES6-8/</id>
    <published>2015-08-07T06:09:19.000Z</published>
    <updated>2015-08-07T06:24:10.000Z</updated>
    <content type="html"><![CDATA[<h1 id="函数参数的默认值">函数参数的默认值</h1>
<p>允许为函数的参数设置默认值，即直接写在参数定义的后面。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
</pre></td><td class="code"><pre>function log(x, y = 'World') {
  console.log(x, y);
}

log('Hello') // Hello World
log('Hello', 'China') // Hello China
log('Hello', '') // Hello
</pre></td></tr></table></figure>

<p>可以为一个对象属性设置默认值</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre>1
2
3
</pre></td><td class="code"><pre>fetch(url, { body = <span class="string">''</span>, method = <span class="string">'GET'</span>, headers = {} }){
  console.log(method);
}
</pre></td></tr></table></figure>

<p>甚至可以设置双重默认值，调用函数fetch时，如果不含第二个参数，则默认值为一个空对象；如果包含第二个参数，则它的method属性默认值为GET。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre>1
2
3
</pre></td><td class="code"><pre>fetch(url, { method = <span class="string">'GET'</span> } = {}){
  console.log(method);
}
</pre></td></tr></table></figure>

<p>如果传入undefined，将触发该参数等于默认值，null则没有这个效果。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
</pre></td><td class="code"><pre><span class="function"><span class="keyword">function</span> <span class="title">foo</span><span class="params">(x = 5, y = 6)</span>{</span>
  console.log(x,y);
}

foo(<span class="literal">undefined</span>, <span class="literal">null</span>)
<span class="comment">// 5 null</span>
</pre></td></tr></table></figure>

<a id="more"></a>
]]></content>
    <summary type="html">
    <![CDATA[<h1 id="函数参数的默认值">函数参数的默认值</h1>
<p>允许为函数的参数设置默认值，即直接写在参数定义的后面。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
</pre></td><td class="code"><pre>function log(x, y = 'World') {
  console.log(x, y);
}

log('Hello') // Hello World
log('Hello', 'China') // Hello China
log('Hello', '') // Hello
</pre></td></tr></table></figure>

<p>可以为一个对象属性设置默认值</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre>1
2
3
</pre></td><td class="code"><pre>fetch(url, { body = <span class="string">''</span>, method = <span class="string">'GET'</span>, headers = {} }){
  console.log(method);
}
</pre></td></tr></table></figure>

<p>甚至可以设置双重默认值，调用函数fetch时，如果不含第二个参数，则默认值为一个空对象；如果包含第二个参数，则它的method属性默认值为GET。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre>1
2
3
</pre></td><td class="code"><pre>fetch(url, { method = <span class="string">'GET'</span> } = {}){
  console.log(method);
}
</pre></td></tr></table></figure>

<p>如果传入undefined，将触发该参数等于默认值，null则没有这个效果。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
</pre></td><td class="code"><pre><span class="function"><span class="keyword">function</span> <span class="title">foo</span><span class="params">(x = 5, y = 6)</span>{</span>
  console.log(x,y);
}

foo(<span class="literal">undefined</span>, <span class="literal">null</span>)
<span class="comment">// 5 null</span>
</pre></td></tr></table></figure>

]]>
    
    </summary>
    
      <category term="ES6" scheme="http://think2011.github.io/tags/ES6/"/>
    
      <category term="ES6" scheme="http://think2011.github.io/categories/ES6/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[ES6(ECMAScript 6)笔记7-对象的扩展]]></title>
    <link href="http://think2011.github.io/2015/08/05/ES6/ES6-7/"/>
    <id>http://think2011.github.io/2015/08/05/ES6/ES6-7/</id>
    <published>2015-08-05T09:38:48.000Z</published>
    <updated>2015-08-07T02:27:33.000Z</updated>
    <content type="html"><![CDATA[<h1 id="属性的简洁表示法">属性的简洁表示法</h1>
<p>允许直接写入变量和函数作为对象的属性和方法，这样的书写更简洁。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
</pre></td><td class="code"><pre><span class="function"><span class="keyword">function</span> <span class="title">f</span><span class="params">( x, y )</span> {</span>
  <span class="keyword">return</span> { x, y };
}

<span class="comment">// 等同于</span>

<span class="function"><span class="keyword">function</span> <span class="title">f</span><span class="params">( x, y )</span> {</span>
  <span class="keyword">return</span> { x: x, y: y };
}

<span class="keyword">var</span> o = {
  method() {
    <span class="keyword">return</span> <span class="string">"Hello!"</span>;
  }
};

<span class="comment">// 等同于</span>

<span class="keyword">var</span> o = {
  method: <span class="function"><span class="keyword">function</span><span class="params">()</span> {</span>
    <span class="keyword">return</span> <span class="string">"Hello!"</span>;
  }
};
install
<span class="keyword">var</span> Person = {

  name: <span class="string">'张三'</span>,

  <span class="comment">//等同于birth: birth</span>
  birth,

  <span class="comment">// 等同于hello: function ()...</span>
  hello() { console.log(<span class="string">'我的名字是'</span>, <span class="keyword">this</span>.name); }

};
</pre></td></tr></table></figure>

<a id="more"></a>
<h1 id="属性名表达式">属性名表达式</h1>
<p>定义对象的属性有2种方法。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
</pre></td><td class="code"><pre><span class="comment">// 方法一</span>
obj.foo = <span class="literal">true</span>;

<span class="comment">// 方法二</span>
obj[<span class="string">'a'</span>+<span class="string">'bc'</span>] = <span class="number">123</span>;

<span class="keyword">var</span> lastWord = <span class="string">"last word"</span>;

<span class="keyword">var</span> a = {
    <span class="string">"first word"</span>: <span class="string">"hello"</span>,
    [lastWord]: <span class="string">"world"</span>
};

a[<span class="string">"first word"</span>] <span class="comment">// "hello"</span>
a[lastWord] <span class="comment">// "world"</span>
a[<span class="string">"last word"</span>] <span class="comment">// "world"</span>
</pre></td></tr></table></figure>

<p>表达式也可用用于定义方法名</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
</pre></td><td class="code"><pre><span class="keyword">let</span> obj = {
  [<span class="string">'h'</span>+<span class="string">'ello'</span>]() {
    <span class="keyword">return</span> <span class="string">'hi'</span>;
  }
};

console.log(obj.hello()); <span class="comment">// hi</span>
</pre></td></tr></table></figure>

<h1 id="方法的name属性">方法的name属性</h1>
<p>函数的name属性，返回函数名。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
9
10
11
</pre></td><td class="code"><pre><span class="keyword">var</span> person = {
  sayName: <span class="function"><span class="keyword">function</span><span class="params">()</span> {</span>
    console.log(<span class="keyword">this</span>.name);
  },
  get firstName() {
    <span class="keyword">return</span> <span class="string">"Nicholas"</span>
  }
}

person.sayName.name   <span class="comment">// "sayName"</span>
person.firstName.name <span class="comment">// "get firstName"</span>
</pre></td></tr></table></figure>

<p>有两种特殊情况：bind方法创造的函数，name属性返回“bound”加上原函数的名字；Function构造函数创造的函数，name属性返回“anonymous”。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
</pre></td><td class="code"><pre><span class="keyword">var</span> doSomething = <span class="function"><span class="keyword">function</span><span class="params">()</span> {</span>
  <span class="comment">// ...</span>
};

console.log(doSomething.bind().name);   <span class="comment">// "bound doSomething"</span>

console.log((<span class="keyword">new</span> <span class="built_in">Function</span>()).name);     <span class="comment">// "anonymous"</span>
</pre></td></tr></table></figure>

<h1 id="Object-is()">Object.is()</h1>
<p>用来比较两个值是否严格相等，它与严格比较 === 的行为基本一致，不同之处只有2个：一个是+0不等于-0，第二个是NaN等于自身。</p>
<p>Object.assign()<br>用来将源对象的所有可枚举属性复制到目前对象，它至少要2个对象作为参数，第一个参数是目标对象，后面的参数都是源对象，并且只要一个参数不是对象，就会TypeError。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
</pre></td><td class="code"><pre><span class="keyword">var</span> target = { a: <span class="number">1</span> };

<span class="keyword">var</span> source1 = { b: <span class="number">2</span> };
<span class="keyword">var</span> source2 = { c: <span class="number">3</span> };

<span class="built_in">Object</span>.assign(target, source1, source2);
target <span class="comment">// {a:1, b:2, c:3}</span>
</pre></td></tr></table></figure>

<p>如果目标对象和源对象有同名，后面的属性覆盖前面的。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
</pre></td><td class="code"><pre><span class="keyword">var</span> target = { a: <span class="number">1</span>, b: <span class="number">1</span> };

<span class="keyword">var</span> source1 = { b: <span class="number">2</span>, c: <span class="number">2</span> };
<span class="keyword">var</span> source2 = { c: <span class="number">3</span> };

<span class="built_in">Object</span>.assign(target, source1, source2);
target <span class="comment">// {a:1, b:2, c:3}</span>
</pre></td></tr></table></figure>

<h1 id="Object-setPrototypeOf()_Object-getPrototypeOf()_Proxy()_get()_set()_apply()_ownKeys()_Reflect()">Object.setPrototypeOf() Object.getPrototypeOf() Proxy() get() set() apply() ownKeys() Reflect()</h1>
<p>略</p>
]]></content>
    <summary type="html">
    <![CDATA[<h1 id="属性的简洁表示法">属性的简洁表示法</h1>
<p>允许直接写入变量和函数作为对象的属性和方法，这样的书写更简洁。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
</pre></td><td class="code"><pre><span class="function"><span class="keyword">function</span> <span class="title">f</span><span class="params">( x, y )</span> {</span>
  <span class="keyword">return</span> { x, y };
}

<span class="comment">// 等同于</span>

<span class="function"><span class="keyword">function</span> <span class="title">f</span><span class="params">( x, y )</span> {</span>
  <span class="keyword">return</span> { x: x, y: y };
}

<span class="keyword">var</span> o = {
  method() {
    <span class="keyword">return</span> <span class="string">"Hello!"</span>;
  }
};

<span class="comment">// 等同于</span>

<span class="keyword">var</span> o = {
  method: <span class="function"><span class="keyword">function</span><span class="params">()</span> {</span>
    <span class="keyword">return</span> <span class="string">"Hello!"</span>;
  }
};
install
<span class="keyword">var</span> Person = {

  name: <span class="string">'张三'</span>,

  <span class="comment">//等同于birth: birth</span>
  birth,

  <span class="comment">// 等同于hello: function ()...</span>
  hello() { console.log(<span class="string">'我的名字是'</span>, <span class="keyword">this</span>.name); }

};
</pre></td></tr></table></figure>

]]>
    
    </summary>
    
      <category term="ES6" scheme="http://think2011.github.io/tags/ES6/"/>
    
      <category term="ES6" scheme="http://think2011.github.io/categories/ES6/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[ES6(ECMAScript 6)笔记6-数组的扩展]]></title>
    <link href="http://think2011.github.io/2015/08/05/ES6/ES6-6/"/>
    <id>http://think2011.github.io/2015/08/05/ES6/ES6-6/</id>
    <published>2015-08-05T03:55:00.000Z</published>
    <updated>2015-08-05T04:02:32.000Z</updated>
    <content type="html"><![CDATA[<h1 id="Array-from()">Array.from()</h1>
<p>将类数组和可遍历的对象转换为真正的数组。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
9
10
11
12
13
14
</pre></td><td class="code"><pre><span class="keyword">let</span> ps = document.querySelectorAll(<span class="string">'p'</span>);

<span class="built_in">Array</span>.from(ps).forEach(<span class="function"><span class="keyword">function</span> <span class="params">(p)</span> {</span>
  console.log(p);
});

<span class="function"><span class="keyword">function</span> <span class="title">foo</span><span class="params">()</span> {</span>
  <span class="keyword">var</span> args = <span class="built_in">Array</span>.from( <span class="built_in">arguments</span> );
}

foo( <span class="string">"a"</span>, <span class="string">"b"</span>, <span class="string">"c"</span> );

<span class="built_in">Array</span>.from({ <span class="number">0</span>: <span class="string">"a"</span>, <span class="number">1</span>: <span class="string">"b"</span>, <span class="number">2</span>: <span class="string">"c"</span>, length: <span class="number">3</span> });
<span class="comment">// [ "a", "b" , "c" ]</span>
</pre></td></tr></table></figure>

<p>同时接受第二个参数，作用类似于map方法，对每个元素进行处理。</p>
<a id="more"></a>
<h1 id="Array-of()">Array.of()</h1>
<p>将一组值转换为数组。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre>1
2
3
</pre></td><td class="code"><pre><span class="built_in">Array</span>.of(<span class="number">3</span>, <span class="number">11</span>, <span class="number">8</span>) <span class="comment">// [3,11,8]</span>
<span class="built_in">Array</span>.of(<span class="number">3</span>) <span class="comment">// [3]</span>
<span class="built_in">Array</span>.of(<span class="number">3</span>).length <span class="comment">// 1</span>
</pre></td></tr></table></figure>

<h1 id="数组实例的find()和findIndex()">数组实例的find()和findIndex()</h1>
<p>find方法用于找出第一个符合条件的数组成员，如果没找到返回undefined。<br>findIndex方法类似find，只是返回的是索引位置，没找到返回-1。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre>1
2
3
</pre></td><td class="code"><pre>[<span class="number">1</span>, <span class="number">5</span>, <span class="number">10</span>, <span class="number">15</span>].find(<span class="function"><span class="keyword">function</span><span class="params">(value, index, arr)</span> {</span>
  <span class="keyword">return</span> value &gt; <span class="number">9</span>;
}) <span class="comment">// 10</span>
</pre></td></tr></table></figure>

<h1 id="数组实例的fill()">数组实例的fill()</h1>
<p>使用给定值，填充一个数组，第二和第三个参数用来指定填充的开始位置和结束位置。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
</pre></td><td class="code"><pre>[<span class="string">'a'</span>, <span class="string">'b'</span>, <span class="string">'c'</span>].fill(<span class="number">7</span>)
<span class="comment">// [7, 7, 7]</span>

<span class="keyword">new</span> <span class="built_in">Array</span>(<span class="number">3</span>).fill(<span class="number">7</span>)
<span class="comment">// [7, 7, 7]</span>

[<span class="string">'a'</span>, <span class="string">'b'</span>, <span class="string">'c'</span>].fill(<span class="number">7</span>, <span class="number">1</span>, <span class="number">2</span>)
<span class="comment">// ['a', 7, 'c']</span>
</pre></td></tr></table></figure>

<h1 id="数组实例的entries()，keys()和values()">数组实例的entries()，keys()和values()</h1>
<p>它们都返回一个遍历器可以用for…of循环遍历，区别在于：</p>
<ul>
<li>keys() 返回键名</li>
<li>values() 返回键值</li>
<li>entries() 返回键值对</li>
</ul>
<figure class="highlight js"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
</pre></td><td class="code"><pre>
<span class="keyword">for</span> (<span class="keyword">let</span> index of [<span class="string">'a'</span>, <span class="string">'b'</span>].keys()) {
  console.log(index);
}
<span class="comment">// 0</span>
<span class="comment">// 1</span>

<span class="keyword">for</span> (<span class="keyword">let</span> elem of [<span class="string">'a'</span>, <span class="string">'b'</span>].values()) {
  console.log(elem);
}
<span class="comment">// 'a'</span>
<span class="comment">// 'b'</span>

<span class="keyword">for</span> (<span class="keyword">let</span> [index, elem] of [<span class="string">'a'</span>, <span class="string">'b'</span>].entries()) {
  console.log(index, elem);
}
<span class="comment">// 0 "a"</span>
<span class="comment">// 1 "b"</span>
</pre></td></tr></table></figure>

]]></content>
    <summary type="html">
    <![CDATA[<h1 id="Array-from()">Array.from()</h1>
<p>将类数组和可遍历的对象转换为真正的数组。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
9
10
11
12
13
14
</pre></td><td class="code"><pre><span class="keyword">let</span> ps = document.querySelectorAll(<span class="string">'p'</span>);

<span class="built_in">Array</span>.from(ps).forEach(<span class="function"><span class="keyword">function</span> <span class="params">(p)</span> {</span>
  console.log(p);
});

<span class="function"><span class="keyword">function</span> <span class="title">foo</span><span class="params">()</span> {</span>
  <span class="keyword">var</span> args = <span class="built_in">Array</span>.from( <span class="built_in">arguments</span> );
}

foo( <span class="string">"a"</span>, <span class="string">"b"</span>, <span class="string">"c"</span> );

<span class="built_in">Array</span>.from({ <span class="number">0</span>: <span class="string">"a"</span>, <span class="number">1</span>: <span class="string">"b"</span>, <span class="number">2</span>: <span class="string">"c"</span>, length: <span class="number">3</span> });
<span class="comment">// [ "a", "b" , "c" ]</span>
</pre></td></tr></table></figure>

<p>同时接受第二个参数，作用类似于map方法，对每个元素进行处理。</p>
]]>
    
    </summary>
    
      <category term="ES6" scheme="http://think2011.github.io/tags/ES6/"/>
    
      <category term="ES6" scheme="http://think2011.github.io/categories/ES6/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[ES6(ECMAScript 6)笔记5-数值的扩展]]></title>
    <link href="http://think2011.github.io/2015/08/05/ES6/ES6-5/"/>
    <id>http://think2011.github.io/2015/08/05/ES6/ES6-5/</id>
    <published>2015-08-05T03:33:55.000Z</published>
    <updated>2015-08-05T03:38:49.000Z</updated>
    <content type="html"><![CDATA[<h1 id="Number-isFinite(),_Number-isNaN()">Number.isFinite(), Number.isNaN()</h1>
<p>前者用来检查一个数值是否非无穷，后者用来检查是否是NaN。</p>
<p>它们与传统的全局方法isFinite()和isNaN()的区别在于，传统方法先调用Number()<br>将非数值的值转为数值，再进行判断，而这两个新方法只对数值有效，非数值一律返回false。</p>
<h1 id="Number-parseInt(),_Number-parseFloat()">Number.parseInt(), Number.parseFloat()</h1>
<p>ES6将全局方法parseInt()和parseFloat()，移植到Number对象上面，行为完全保持不变。</p>
<a id="more"></a>
<h1 id="Number-isInteger()和安全整数">Number.isInteger()和安全整数</h1>
<p>Number.isInteger()用来判断一个值是否为整数。需要注意的是，在JavaScript内部，整数和浮点数是同样的储存方法，所以3和3.0被视为同一个值。</p>
<h1 id="Math-trunc()">Math.trunc()</h1>
<p>去除一个数的小数部分，返回整数部分。</p>
<h1 id="Math-sign()">Math.sign()</h1>
<p>判断一个数是正数、负数、还是零，它会返回五种值。</p>
<ul>
<li>参数为正数，返回+1；</li>
<li>参数为负数，返回-1；</li>
<li>参数为0，返回0；</li>
<li>参数为-0，返回-0;</li>
<li>其他值，返回NaN。</li>
</ul>
<h1 id="二进制和八进制表示法_Math-cbrt()_Math-clz32()_Math-imul()_Math-fround()_Math-hypot()_Math-expm1()_Math-log1p()_Math-log10()_Math-log2()">二进制和八进制表示法 Math.cbrt() Math.clz32() Math.imul() Math.fround() Math.hypot() Math.expm1() Math.log1p() Math.log10() Math.log2()</h1>
<p>略</p>
]]></content>
    <summary type="html">
    <![CDATA[<h1 id="Number-isFinite(),_Number-isNaN()">Number.isFinite(), Number.isNaN()</h1>
<p>前者用来检查一个数值是否非无穷，后者用来检查是否是NaN。</p>
<p>它们与传统的全局方法isFinite()和isNaN()的区别在于，传统方法先调用Number()<br>将非数值的值转为数值，再进行判断，而这两个新方法只对数值有效，非数值一律返回false。</p>
<h1 id="Number-parseInt(),_Number-parseFloat()">Number.parseInt(), Number.parseFloat()</h1>
<p>ES6将全局方法parseInt()和parseFloat()，移植到Number对象上面，行为完全保持不变。</p>
]]>
    
    </summary>
    
      <category term="ES6" scheme="http://think2011.github.io/tags/ES6/"/>
    
      <category term="ES6" scheme="http://think2011.github.io/categories/ES6/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[ES6(ECMAScript 6)笔记4-正则的扩展]]></title>
    <link href="http://think2011.github.io/2015/08/05/ES6/ES6-4/"/>
    <id>http://think2011.github.io/2015/08/05/ES6/ES6-4/</id>
    <published>2015-08-05T02:13:42.000Z</published>
    <updated>2015-08-05T02:27:00.000Z</updated>
    <content type="html"><![CDATA[<h1 id="RegExp构造函数">RegExp构造函数</h1>
<p>ES5中RegExp构造函数值接受字符串作为参数，而ES6支持真个表达式作为参数。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre>1
</pre></td><td class="code"><pre><span class="keyword">var</span> reg = <span class="keyword">new</span> <span class="built_in">RegExp</span>(<span class="regexp">/xyz/i</span>);
</pre></td></tr></table></figure>

<p>如果使用RegExp构造函数的第二个参数指定修饰符，则返回的表达式会忽略原有的修饰符，使用新指定的。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre>1
2
</pre></td><td class="code"><pre>

</pre></td></tr></table></figure>

<h1 id="y修饰符">y修饰符</h1>
<p>y修饰符也叫做 粘连（sticky）修饰符，作用与g类似，也是全局匹配，后一次匹配都从上一次匹配成功的下一个位置开始，不同之处在于，g修饰符只要剩余位置中存在匹配即可，而y修饰符确保匹配必须从剩余的第一个位置开始，也就是 粘连 的含义。</p>
<a id="more"></a>
<figure class="highlight js"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
9
</pre></td><td class="code"><pre><span class="keyword">var</span> s = <span class="string">"aaa_aa_a"</span>;
<span class="keyword">var</span> r1 = <span class="regexp">/a+/g</span>;
<span class="keyword">var</span> r2 = <span class="regexp">/a+/</span>y;

r1.exec(s) <span class="comment">// ["aaa"]</span>
r2.exec(s) <span class="comment">// ["aaa"]</span>

r1.exec(s) <span class="comment">// ["aa"]</span>
r2.exec(s) <span class="comment">// null</span>
</pre></td></tr></table></figure>

<h1 id="sticky属性">sticky属性</h1>
<p>表示是否设置了y修饰符</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre>1
2
</pre></td><td class="code"><pre><span class="keyword">var</span> r = <span class="regexp">/hello\d/</span>y;
r.sticky <span class="comment">// true</span>
</pre></td></tr></table></figure>

<h1 id="flags属性">flags属性</h1>
<p>会返回正则表达式的修饰符</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
9
</pre></td><td class="code"><pre><span class="comment">// ES5的source属性</span>
<span class="comment">// 返回正则表达式的正文</span>
/abc/ig.source
<span class="comment">// "abc"</span>

<span class="comment">// ES6的flags属性</span>
<span class="comment">// 返回正则表达式的修饰符</span>
/abc/ig.flags
<span class="comment">// 'gi'</span>
</pre></td></tr></table></figure>

<h1 id="u修饰符_点修饰符_Unicode字符表示法_量词_预定义模式_i修饰符">u修饰符 点修饰符 Unicode字符表示法 量词 预定义模式 i修饰符</h1>
<p>略</p>
]]></content>
    <summary type="html">
    <![CDATA[<h1 id="RegExp构造函数">RegExp构造函数</h1>
<p>ES5中RegExp构造函数值接受字符串作为参数，而ES6支持真个表达式作为参数。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre>1
</pre></td><td class="code"><pre><span class="keyword">var</span> reg = <span class="keyword">new</span> <span class="built_in">RegExp</span>(<span class="regexp">/xyz/i</span>);
</pre></td></tr></table></figure>

<p>如果使用RegExp构造函数的第二个参数指定修饰符，则返回的表达式会忽略原有的修饰符，使用新指定的。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre>1
2
</pre></td><td class="code"><pre>

</pre></td></tr></table></figure>

<h1 id="y修饰符">y修饰符</h1>
<p>y修饰符也叫做 粘连（sticky）修饰符，作用与g类似，也是全局匹配，后一次匹配都从上一次匹配成功的下一个位置开始，不同之处在于，g修饰符只要剩余位置中存在匹配即可，而y修饰符确保匹配必须从剩余的第一个位置开始，也就是 粘连 的含义。</p>
]]>
    
    </summary>
    
      <category term="ES6" scheme="http://think2011.github.io/tags/ES6/"/>
    
      <category term="ES6" scheme="http://think2011.github.io/categories/ES6/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[ES6(ECMAScript 6)笔记3-字符串的扩展]]></title>
    <link href="http://think2011.github.io/2015/08/04/ES6/ES6-3/"/>
    <id>http://think2011.github.io/2015/08/04/ES6/ES6-3/</id>
    <published>2015-08-04T09:43:52.000Z</published>
    <updated>2015-08-04T10:38:28.000Z</updated>
    <content type="html"><![CDATA[<h1 id="includes(),_startsWith(),_endsWith()">includes(), startsWith(), endsWith()</h1>
<ul>
<li>includes()：返回布尔值，表示是否找到了参数字符串。</li>
<li>startsWith()：返回布尔值，表示参数字符串是否在源字符串的头部。</li>
<li>endsWith()：返回布尔值，表示参数字符串是否在源字符串的尾部。</li>
</ul>
<figure class="highlight js"><table><tr><td class="gutter"><pre>1
2
3
4
5
</pre></td><td class="code"><pre><span class="keyword">var</span> s = <span class="string">"Hello world!"</span>;

s.startsWith(<span class="string">"Hello"</span>) <span class="comment">// true</span>
s.endsWith(<span class="string">"!"</span>) <span class="comment">// true</span>
s.includes(<span class="string">"o"</span>) <span class="comment">// true</span>
</pre></td></tr></table></figure>

<p>以上都支持第二个参数，表示开始搜索的位置。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre>1
2
3
4
5
</pre></td><td class="code"><pre><span class="keyword">var</span> s = <span class="string">"Hello world!"</span>;

s.startsWith(<span class="string">"world"</span>, <span class="number">6</span>) <span class="comment">// true</span>
s.endsWith(<span class="string">"Hello"</span>, <span class="number">5</span>) <span class="comment">// true</span>
s.includes(<span class="string">"Hello"</span>, <span class="number">6</span>) <span class="comment">// false</span>
</pre></td></tr></table></figure>

<a id="more"></a>
<h1 id="repeat()">repeat()</h1>
<p>返回一个新的字符串，表示重复N次。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre>1
2
</pre></td><td class="code"><pre><span class="string">"x"</span>.repeat(<span class="number">3</span>) <span class="comment">// "xxx"</span>
<span class="string">"hello"</span>.repeat(<span class="number">2</span>) <span class="comment">// "hellohello"</span>
</pre></td></tr></table></figure>

<h1 id="模板字符串">模板字符串</h1>
<p>传统的输出模板是这样写的：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
</pre></td><td class="code"><pre>$(<span class="string">"#result"</span>).append(
  <span class="string">"There are &lt;b&gt;"</span> + basket.count + <span class="string">"&lt;/b&gt; "</span> +
  <span class="string">"items in your basket, "</span> +
  <span class="string">"&lt;em&gt;"</span> + basket.onSale +
  <span class="string">"&lt;/em&gt; are on sale!"</span>
);
</pre></td></tr></table></figure>

<p>在ES6中可以这样写了</p>
<p>用反引号（`）标识。它可以当作普通字符串使用，也可以用来定义多行字符串，或者在字符串中嵌入变量。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre>1
2
3
4
5
</pre></td><td class="code"><pre>$("#result").append(`
  There are &lt;b&gt;${basket.count}&lt;/b&gt; items
   in your basket, &lt;em&gt;${basket.onSale}&lt;/em&gt;
  are on sale!
`);
</pre></td></tr></table></figure>

<h2 id="大括号内部可以放任意的表达式、函数，也可以进行运算和引用对象属性。">大括号内部可以放任意的表达式、函数，也可以进行运算和引用对象属性。</h2>
<figure class="highlight js"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
9
10
11
12
</pre></td><td class="code"><pre><span class="keyword">var</span> x = <span class="number">1</span>;
<span class="keyword">var</span> y = <span class="number">2</span>;

console.log(`${x} + ${y} = ${x+y}`)
<span class="comment">// "1 + 2 = 3"</span>

console.log(`${x} + ${y*<span class="number">2</span>} = ${x+y*<span class="number">2</span>}`)
<span class="comment">// "1 + 4 = 5"</span>

<span class="keyword">var</span> obj = {x: <span class="number">1</span>, y: <span class="number">2</span>};
console.log(`${obj.x + obj.y}`)
<span class="comment">// 3</span>
</pre></td></tr></table></figure>

<h1 id="标签模板">标签模板</h1>
<p>模板字符串的功能不只是上面这些，它还可以紧跟着一个函数名后面，该函数将被调用来处理这个字符串。</p>
<p><figure class="highlight js"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
9
10
</pre></td><td class="code"><pre><span class="keyword">let</span> a = <span class="number">5</span>,
  b = <span class="number">10</span>;

tag `Hello ${a + b} world ${a * b}`;

<span class="function"><span class="keyword">function</span> <span class="title">tag</span><span class="params">(stringArr, val1, val2)</span> {</span>
  console.log(stringArr); <span class="comment">// [ 'Hello ', ' world ', '' ]</span>
  console.log(val1);  <span class="comment">// 15</span>
  console.log(val2); <span class="comment">// 50</span>
}
</pre></td></tr></table></figure><br>tag的第一个参数是一个数组，里面放的是模板字符串中没有被变量替换的部分。<br>其他的参数都是模板字符串被各个变量替换后的值，因为上面的例子中只有2个变量，所以会接收到 val1 和 val2。</p>
<h1 id="String-fromCodePoint(),_raw(),_codePointAt(),_at(),_normalize()">String.fromCodePoint(), raw(), codePointAt(), at(), normalize()</h1>
<p>略</p>
]]></content>
    <summary type="html">
    <![CDATA[<h1 id="includes(),_startsWith(),_endsWith()">includes(), startsWith(), endsWith()</h1>
<ul>
<li>includes()：返回布尔值，表示是否找到了参数字符串。</li>
<li>startsWith()：返回布尔值，表示参数字符串是否在源字符串的头部。</li>
<li>endsWith()：返回布尔值，表示参数字符串是否在源字符串的尾部。</li>
</ul>
<figure class="highlight js"><table><tr><td class="gutter"><pre>1
2
3
4
5
</pre></td><td class="code"><pre><span class="keyword">var</span> s = <span class="string">"Hello world!"</span>;

s.startsWith(<span class="string">"Hello"</span>) <span class="comment">// true</span>
s.endsWith(<span class="string">"!"</span>) <span class="comment">// true</span>
s.includes(<span class="string">"o"</span>) <span class="comment">// true</span>
</pre></td></tr></table></figure>

<p>以上都支持第二个参数，表示开始搜索的位置。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre>1
2
3
4
5
</pre></td><td class="code"><pre><span class="keyword">var</span> s = <span class="string">"Hello world!"</span>;

s.startsWith(<span class="string">"world"</span>, <span class="number">6</span>) <span class="comment">// true</span>
s.endsWith(<span class="string">"Hello"</span>, <span class="number">5</span>) <span class="comment">// true</span>
s.includes(<span class="string">"Hello"</span>, <span class="number">6</span>) <span class="comment">// false</span>
</pre></td></tr></table></figure>

]]>
    
    </summary>
    
      <category term="ES6" scheme="http://think2011.github.io/tags/ES6/"/>
    
      <category term="ES6" scheme="http://think2011.github.io/categories/ES6/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[ES6(ECMAScript 6)笔记2-变量的解构赋值]]></title>
    <link href="http://think2011.github.io/2015/08/04/ES6/ES6-2/"/>
    <id>http://think2011.github.io/2015/08/04/ES6/ES6-2/</id>
    <published>2015-08-04T09:43:25.000Z</published>
    <updated>2015-08-04T09:43:31.000Z</updated>
    <content type="html"><![CDATA[<h1 id="概念">概念</h1>
<p>按照一定的模式，从数组和对象中提取值，对变量进行赋值，这个被成为解构。</p>
<h1 id="数组的解构赋值">数组的解构赋值</h1>
<p>下面表示可以从数组中提取值，按照对应的位置对变量赋值。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
9
10
11
</pre></td><td class="code"><pre><span class="keyword">let</span> [foo, [[bar], baz]] = [<span class="number">1</span>, [[<span class="number">2</span>], <span class="number">3</span>]];
foo <span class="comment">// 1</span>
bar <span class="comment">// 2</span>
baz <span class="comment">// 3</span>

<span class="keyword">let</span> [,,third] = [<span class="string">"foo"</span>, <span class="string">"bar"</span>, <span class="string">"baz"</span>];
third <span class="comment">// "baz"</span>

<span class="keyword">let</span> [x, , y] = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>];
x <span class="comment">// 1</span>
y <span class="comment">// 3</span>
</pre></td></tr></table></figure>

<a id="more"></a>
<h2 id="不完全解构">不完全解构</h2>
<p>等号左边的模式只匹配一部分等号右边的数组，这种情况依然可以解构。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
</pre></td><td class="code"><pre><span class="keyword">let</span> [x, y] = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>];
x <span class="comment">// 1</span>
y <span class="comment">// 2</span>

<span class="keyword">let</span> [a, [b], d] = [<span class="number">1</span>, [<span class="number">2</span>, <span class="number">3</span>], <span class="number">4</span>];
a <span class="comment">// 1</span>
b <span class="comment">// 2</span>
d <span class="comment">// 4</span>
</pre></td></tr></table></figure>

<h2 id="对undefined和null进行解构会出错。">对undefined和null进行解构会出错。</h2>
<p>因为解构只能用于数组或对象，其他原始类型的值都可以转换为对应的对象，但是undefined和null不能，所以报错。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre>1
2
3
</pre></td><td class="code"><pre><span class="comment">// 报错</span>
<span class="keyword">let</span> [foo] = <span class="literal">undefined</span>;
<span class="keyword">let</span> [foo] = <span class="literal">null</span>;
</pre></td></tr></table></figure>

<h2 id="解构允许指定默认值">解构允许指定默认值</h2>
<p>值得注意的是ES6内部使用严格相等（===），所以如果一个数组对象不等于undefined默认不会生效。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
9
10
11
</pre></td><td class="code"><pre><span class="keyword">var</span> [foo = <span class="literal">true</span>] = [];
foo <span class="comment">// true</span>

[x, y=<span class="string">'b'</span>] = [<span class="string">'a'</span>] <span class="comment">// x='a', y='b'</span>
[x, y=<span class="string">'b'</span>] = [<span class="string">'a'</span>, <span class="literal">undefined</span>] <span class="comment">// x='a', y='b'</span>

<span class="keyword">var</span> [x = <span class="number">1</span>] = [<span class="literal">undefined</span>];
x <span class="comment">// 1</span>

<span class="keyword">var</span> [x = <span class="number">1</span>] = [<span class="literal">null</span>];
x <span class="comment">// null</span>
</pre></td></tr></table></figure>

<h1 id="对象的解构赋值">对象的解构赋值</h1>
<p>对象的解构与数组有一个重要的不同，数组的元素是按次数排列的，变量的取值由它的位置决定，对象没有次序，是按照属性名的。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre>1
2
3
</pre></td><td class="code"><pre><span class="keyword">var</span> { foo, bar } = { foo: <span class="string">"aaa"</span>, bar: <span class="string">"bbb"</span> };
foo <span class="comment">// "aaa"</span>
bar <span class="comment">// "bbb"</span>
</pre></td></tr></table></figure>

<h2 id="如果变量名和属性名不一致，必须写成下面这样。">如果变量名和属性名不一致，必须写成下面这样。</h2>
<figure class="highlight js"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
</pre></td><td class="code"><pre><span class="keyword">var</span> { foo: baz } = { foo: <span class="string">"aaa"</span>, bar: <span class="string">"bbb"</span> };
baz <span class="comment">// "aaa"</span>

<span class="keyword">let</span> obj = { first: <span class="string">'hello'</span>, last: <span class="string">'world'</span> };
<span class="keyword">let</span> { first: f, last: l } = obj;
f <span class="comment">// 'hello'</span>
l <span class="comment">// 'world'</span>
</pre></td></tr></table></figure>

<h1 id="函数参数的解构赋值">函数参数的解构赋值</h1>
<figure class="highlight js"><table><tr><td class="gutter"><pre>1
2
3
4
5
</pre></td><td class="code"><pre><span class="function"><span class="keyword">function</span> <span class="title">add</span><span class="params">([x, y])</span>{</span>
  <span class="keyword">return</span> x + y;
}

add([<span class="number">1</span>, <span class="number">2</span>]) <span class="comment">// 3</span>
</pre></td></tr></table></figure>

<h1 id="用途">用途</h1>
<h2 id="交换变量的值">交换变量的值</h2>
<figure class="highlight js"><table><tr><td class="gutter"><pre>1
</pre></td><td class="code"><pre>[x, y] = [y, x];
</pre></td></tr></table></figure>

<h2 id="从函数返回多个值">从函数返回多个值</h2>
<p>函数只能返回一个值，如果要返回多个值只能放在数组或者对象里，有了解构赋值取出这些值就方便多了。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
</pre></td><td class="code"><pre><span class="comment">// 返回一个数组</span>

<span class="function"><span class="keyword">function</span> <span class="title">example</span><span class="params">()</span> {</span>
  <span class="keyword">return</span> [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>];
}
<span class="keyword">var</span> [a, b, c] = example();

<span class="comment">// 返回一个对象</span>

<span class="function"><span class="keyword">function</span> <span class="title">example</span><span class="params">()</span> {</span>
  <span class="keyword">return</span> {
    foo: <span class="number">1</span>,
    bar: <span class="number">2</span>
  };
}
<span class="keyword">var</span> { foo, bar } = example();
</pre></td></tr></table></figure>

<h2 id="函数参数的定义">函数参数的定义</h2>
<p>方便的将一组参数与变量名对应起来。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
</pre></td><td class="code"><pre>
<span class="comment">// 参数是一组有次序的值</span>
<span class="function"><span class="keyword">function</span> <span class="title">f</span><span class="params">([x, y, z])</span> {</span> ... }
f([<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>])

<span class="comment">// 参数是一组无次序的值</span>
<span class="function"><span class="keyword">function</span> <span class="title">f</span><span class="params">({x, y, z})</span> {</span> ... }
f({x:<span class="number">1</span>, y:<span class="number">2</span>, z:<span class="number">3</span>})
</pre></td></tr></table></figure>

<h2 id="提取JSON数组">提取JSON数组</h2>
<figure class="highlight js"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
9
10
</pre></td><td class="code"><pre><span class="keyword">var</span> jsonData = {
  id: <span class="number">42</span>,
  status: <span class="string">"OK"</span>,
  data: [<span class="number">867</span>, <span class="number">5309</span>]
}

<span class="keyword">let</span> { id, status, data: number } = jsonData;

console.log(id, status, number)
<span class="comment">// 42, OK, [867, 5309]</span>
</pre></td></tr></table></figure>

<h2 id="函数参数的默认值">函数参数的默认值</h2>
<figure class="highlight js"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
9
10
11
</pre></td><td class="code"><pre>jQuery.ajax = function (url, {
  async = true,
  beforeSend = function () {},
  cache = true,
  complete = function () {},
  crossDomain = false,
  global = true,
  // ... more config
}) {
  // ... do stuff
};
</pre></td></tr></table></figure>

]]></content>
    <summary type="html">
    <![CDATA[<h1 id="概念">概念</h1>
<p>按照一定的模式，从数组和对象中提取值，对变量进行赋值，这个被成为解构。</p>
<h1 id="数组的解构赋值">数组的解构赋值</h1>
<p>下面表示可以从数组中提取值，按照对应的位置对变量赋值。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
9
10
11
</pre></td><td class="code"><pre><span class="keyword">let</span> [foo, [[bar], baz]] = [<span class="number">1</span>, [[<span class="number">2</span>], <span class="number">3</span>]];
foo <span class="comment">// 1</span>
bar <span class="comment">// 2</span>
baz <span class="comment">// 3</span>

<span class="keyword">let</span> [,,third] = [<span class="string">"foo"</span>, <span class="string">"bar"</span>, <span class="string">"baz"</span>];
third <span class="comment">// "baz"</span>

<span class="keyword">let</span> [x, , y] = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>];
x <span class="comment">// 1</span>
y <span class="comment">// 3</span>
</pre></td></tr></table></figure>

]]>
    
    </summary>
    
      <category term="ES6" scheme="http://think2011.github.io/tags/ES6/"/>
    
      <category term="ES6" scheme="http://think2011.github.io/categories/ES6/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[ES6(ECMAScript 6)笔记1-let和const]]></title>
    <link href="http://think2011.github.io/2015/08/04/ES6/ES6-1/"/>
    <id>http://think2011.github.io/2015/08/04/ES6/ES6-1/</id>
    <published>2015-08-04T03:00:38.000Z</published>
    <updated>2015-08-04T03:34:53.000Z</updated>
    <content type="html"><![CDATA[<h1 id="let命令">let命令</h1>
<p>let用来声明变量，但声明的作用只在代码块内有效。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
</pre></td><td class="code"><pre>{
  <span class="keyword">let</span> a = <span class="number">10</span>;
  <span class="keyword">var</span> b = <span class="number">1</span>;
}

a <span class="comment">// ReferenceError: a is not defined.</span>
b <span class="comment">// 1</span>
</pre></td></tr></table></figure>

<a id="more"></a>
<p>for循环就很适合使用let命令,不会存在ES5中需要闭包解决的问题。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
</pre></td><td class="code"><pre><span class="keyword">var</span> a = [];
<span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) {
  a[i] = <span class="function"><span class="keyword">function</span> <span class="params">()</span> {</span>
    console.log(i);
  };
}
a[<span class="number">6</span>](); <span class="comment">// 6</span>
</pre></td></tr></table></figure>

<p>不存在变量提升</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre>1
2
3
4
</pre></td><td class="code"><pre><span class="function"><span class="keyword">function</span> <span class="title">do_something</span><span class="params">()</span> {</span>
  console.log(foo); <span class="comment">// ReferenceError</span>
  <span class="keyword">let</span> foo = <span class="number">2</span>;
}
</pre></td></tr></table></figure>

<p>不允许重复声明</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
9
10
11
</pre></td><td class="code"><pre><span class="comment">// 报错</span>
<span class="function"><span class="keyword">function</span> <span class="params">()</span> {</span>
  <span class="keyword">let</span> a = <span class="number">10</span>;
  <span class="keyword">var</span> a = <span class="number">1</span>;
}

<span class="comment">// 报错</span>
<span class="function"><span class="keyword">function</span> <span class="params">()</span> {</span>
  <span class="keyword">let</span> a = <span class="number">10</span>;
  <span class="keyword">let</span> a = <span class="number">1</span>;
}
</pre></td></tr></table></figure>

<h1 id="const命令">const命令</h1>
<p>用来声明常量，一旦声明，常量的值就不能改变了。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
</pre></td><td class="code"><pre><span class="keyword">const</span> PI = <span class="number">3.1415</span>;
PI <span class="comment">// 3.1415</span>

PI = <span class="number">3</span>;
PI <span class="comment">// 3.1415</span>

<span class="keyword">const</span> PI = <span class="number">3.1</span>;
PI <span class="comment">// 3.1415</span>
</pre></td></tr></table></figure>
]]></content>
    <summary type="html">
    <![CDATA[<h1 id="let命令">let命令</h1>
<p>let用来声明变量，但声明的作用只在代码块内有效。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
</pre></td><td class="code"><pre>{
  <span class="keyword">let</span> a = <span class="number">10</span>;
  <span class="keyword">var</span> b = <span class="number">1</span>;
}

a <span class="comment">// ReferenceError: a is not defined.</span>
b <span class="comment">// 1</span>
</pre></td></tr></table></figure>

]]>
    
    </summary>
    
      <category term="ES6" scheme="http://think2011.github.io/tags/ES6/"/>
    
      <category term="ES6" scheme="http://think2011.github.io/categories/ES6/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[再一次，javascript设计模式与开发实践-开放-封闭原则]]></title>
    <link href="http://think2011.github.io/2015/07/15/design%20pattern%20in%20action/%E5%BC%80%E6%94%BE-%E5%B0%81%E9%97%AD%E5%8E%9F%E5%88%99/"/>
    <id>http://think2011.github.io/2015/07/15/design pattern in action/开放-封闭原则/</id>
    <published>2015-07-15T14:45:19.000Z</published>
    <updated>2015-07-15T15:02:29.000Z</updated>
    <content type="html"><![CDATA[<h2 id="定义">定义</h2>
<p>很多时候，一个程序具有良好的设计，它通常是符合开发-封闭原则的。</p>
<blockquote>
<p>软件实体（类、模块、函数）等应该是可以扩展的，但是不可修改的。</p>
</blockquote>
<h2 id="例子">例子</h2>
<p>过多的if是造成违反开发-封闭原则的一个常见原因。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
9
10
11
12
13
14
</pre></td><td class="code"><pre><span class="keyword">var</span> markSound = <span class="function"><span class="keyword">function</span> <span class="params">(animal)</span> {</span>
    <span class="keyword">if</span> (animal <span class="keyword">instanceof</span> Duck) {
        console.log(<span class="string">'嘎嘎嘎'</span>);
    }
    <span class="keyword">else</span> <span class="keyword">if</span> (animal <span class="keyword">instanceof</span> Chicken) {
        console.log(<span class="string">'咯咯咯'</span>);
    }
};

<span class="keyword">var</span> Duck    = <span class="function"><span class="keyword">function</span> <span class="params">()</span> {</span>};
<span class="keyword">var</span> Chicken = <span class="function"><span class="keyword">function</span> <span class="params">()</span> {</span>};

markSound(Duck());
markSound(Chicken());
</pre></td></tr></table></figure>

<p>显然如果动物世界再增加一只狗之后，我们必须改写markSound函数。</p>
<a id="more"></a>
<p>如果利用多态的思想，把程序中不变的部分隔离开来（动物都会叫），然后把可变的部分封装起来（不同的叫声），那么程序就具有可扩展性。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
</pre></td><td class="code"><pre><span class="keyword">var</span> markSound = <span class="function"><span class="keyword">function</span> <span class="params">(animal)</span> {</span>
    animal.sound();
};

<span class="keyword">var</span> Duck = <span class="function"><span class="keyword">function</span> <span class="params">()</span> {</span>};

Duck.prototype.sound = <span class="function"><span class="keyword">function</span> <span class="params">()</span> {</span>
    console.log(<span class="string">'嘎嘎嘎'</span>);
};

<span class="keyword">var</span> Chicken = <span class="function"><span class="keyword">function</span> <span class="params">()</span> {</span>};

Chicken.prototype.sound = <span class="function"><span class="keyword">function</span> <span class="params">()</span> {</span>
    console.log(<span class="string">'咯咯咯'</span>);
};

markSound(<span class="keyword">new</span> Duck());
markSound(<span class="keyword">new</span> Chicken());


<span class="keyword">var</span> Dog = <span class="function"><span class="keyword">function</span> <span class="params">()</span> {</span>};

Dog.prototype.sound = <span class="function"><span class="keyword">function</span> <span class="params">()</span> {</span>
    console.log(<span class="string">'汪汪汪'</span>);
};
</pre></td></tr></table></figure>

<h2 id="找出变化的部分">找出变化的部分</h2>
<p>最明显的就是找出程序中发生变化的地方，然后把变化封装起来。</p>
<h2 id="开发-封闭原则的相对性">开发-封闭原则的相对性</h2>
<p>实际上让程序保持完全封闭是不容易做到的，总会存在一些无法对其封闭的变化，作为程序猿，我们可以做到下面两点。</p>
<ul>
<li>挑出最容易发生变化的地方，然后 构造抽象来封闭这些变化。</li>
<li>在不可避免发生修改的时候，尽量修改那些相对容易修改的地方。</li>
</ul>
<h2 id="接受第一次的愚弄">接受第一次的愚弄</h2>
<blockquote>
<p>有句古老的谚语：愚弄我一次，应该羞愧的是你，再次愚弄我，应该羞愧的是我。</p>
</blockquote>
<p>让程序一开始就尽量遵守开发-封闭原则，并不是容易的事情。<br>一方面我们需要知道程序哪些地方会发现变化，这要求我们有一些”未卜先知”的能力，另一方面留给需求排期的时间并不是无限的。<br>所以我们可以说服自己去接受不合理的代码带来的第一次愚弄。<br>在最初编写代码的时候，先假设永远不会发生变化，这有利于我们迅速完成需求，当变化发生且对我们工作造成影响时，可以再回过头来封装这些变化。</p>
]]></content>
    <summary type="html">
    <![CDATA[<h2 id="定义">定义</h2>
<p>很多时候，一个程序具有良好的设计，它通常是符合开发-封闭原则的。</p>
<blockquote>
<p>软件实体（类、模块、函数）等应该是可以扩展的，但是不可修改的。</p>
</blockquote>
<h2 id="例子">例子</h2>
<p>过多的if是造成违反开发-封闭原则的一个常见原因。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
9
10
11
12
13
14
</pre></td><td class="code"><pre><span class="keyword">var</span> markSound = <span class="function"><span class="keyword">function</span> <span class="params">(animal)</span> {</span>
    <span class="keyword">if</span> (animal <span class="keyword">instanceof</span> Duck) {
        console.log(<span class="string">'嘎嘎嘎'</span>);
    }
    <span class="keyword">else</span> <span class="keyword">if</span> (animal <span class="keyword">instanceof</span> Chicken) {
        console.log(<span class="string">'咯咯咯'</span>);
    }
};

<span class="keyword">var</span> Duck    = <span class="function"><span class="keyword">function</span> <span class="params">()</span> {</span>};
<span class="keyword">var</span> Chicken = <span class="function"><span class="keyword">function</span> <span class="params">()</span> {</span>};

markSound(Duck());
markSound(Chicken());
</pre></td></tr></table></figure>

<p>显然如果动物世界再增加一只狗之后，我们必须改写markSound函数。</p>
]]>
    
    </summary>
    
      <category term="javascript" scheme="http://think2011.github.io/tags/javascript/"/>
    
      <category term="设计模式" scheme="http://think2011.github.io/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
      <category term="实战" scheme="http://think2011.github.io/tags/%E5%AE%9E%E6%88%98/"/>
    
      <category term="笔记" scheme="http://think2011.github.io/categories/%E7%AC%94%E8%AE%B0/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[再一次，javascript设计模式与开发实践-最少知识原则]]></title>
    <link href="http://think2011.github.io/2015/07/15/design%20pattern%20in%20action/%E6%9C%80%E5%B0%91%E7%9F%A5%E8%AF%86%E5%8E%9F%E5%88%99/"/>
    <id>http://think2011.github.io/2015/07/15/design pattern in action/最少知识原则/</id>
    <published>2015-07-15T14:38:28.000Z</published>
    <updated>2015-07-15T14:44:41.000Z</updated>
    <content type="html"><![CDATA[<h2 id="定义">定义</h2>
<p>某军队中的将军需要挖掘一些散兵坑，下面是完成任务的一种方式：</p>
<blockquote>
<p>将军通知上校，上校通知上尉，上尉通知军士，最后军士叫来士兵，让士兵来挖一些散兵坑。</p>
</blockquote>
<p>将军根本不必考虑挖散兵坑的细节信息，只要通知下属就好了，</p>
<h2 id="减少对象之间的联系">减少对象之间的联系</h2>
<p>在程序中，对象的“朋友”多并不是一件好事，“城门失火，殃及池鱼”和“一人犯法，株连九族”的事情时有发生..<br>最少知识原则要求我们在设计程序时，应当尽可能的减少对象之间的交互，如果两个对象之间不必彼此直接通信，那么这两个对象就不要发生直接的相互联系。<br>常见的做法是引入一个第三者对象来承担这些对象之间的通信。</p>
<a id="more"></a>
<h2 id="封装在最少知识原则中的体现">封装在最少知识原则中的体现</h2>
<p>封装在很大程序上表达的是数据的隐藏，一个模块或者对象可以将内部的数据或者实现细节隐藏起来，只暴露必要的接口API供外界访问，这样我们可以让对象只暴露必要的接口，从而当对象之间的联系限制在最小的范围内。</p>
]]></content>
    <summary type="html">
    <![CDATA[<h2 id="定义">定义</h2>
<p>某军队中的将军需要挖掘一些散兵坑，下面是完成任务的一种方式：</p>
<blockquote>
<p>将军通知上校，上校通知上尉，上尉通知军士，最后军士叫来士兵，让士兵来挖一些散兵坑。</p>
</blockquote>
<p>将军根本不必考虑挖散兵坑的细节信息，只要通知下属就好了，</p>
<h2 id="减少对象之间的联系">减少对象之间的联系</h2>
<p>在程序中，对象的“朋友”多并不是一件好事，“城门失火，殃及池鱼”和“一人犯法，株连九族”的事情时有发生..<br>最少知识原则要求我们在设计程序时，应当尽可能的减少对象之间的交互，如果两个对象之间不必彼此直接通信，那么这两个对象就不要发生直接的相互联系。<br>常见的做法是引入一个第三者对象来承担这些对象之间的通信。</p>
]]>
    
    </summary>
    
      <category term="javascript" scheme="http://think2011.github.io/tags/javascript/"/>
    
      <category term="设计模式" scheme="http://think2011.github.io/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
      <category term="实战" scheme="http://think2011.github.io/tags/%E5%AE%9E%E6%88%98/"/>
    
      <category term="笔记" scheme="http://think2011.github.io/categories/%E7%AC%94%E8%AE%B0/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[再一次，javascript设计模式与开发实践-单一职责原则]]></title>
    <link href="http://think2011.github.io/2015/07/15/design%20pattern%20in%20action/%E5%8D%95%E4%B8%80%E8%81%8C%E8%B4%A3%E5%8E%9F%E5%88%99/"/>
    <id>http://think2011.github.io/2015/07/15/design pattern in action/单一职责原则/</id>
    <published>2015-07-15T13:52:03.000Z</published>
    <updated>2015-07-15T13:52:04.000Z</updated>
    <content type="html"><![CDATA[<h2 id="定义">定义</h2>
<p>如果我们有两个动机去改写一个方法，那么这个方法就具有两个职责。<br>每个职责都是变化的一个轴线，如果一个方法承担了过多的职责，那么在需求变化的过程中，需要改写这个方法的可能性就越大。<br>因此，单一职责(SRP)原则体现为：一个对象（方法）只做一件事。</p>
<h2 id="例子">例子</h2>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
</pre></td><td class="code"><pre><span class="keyword">var</span> createLayer = (<span class="function"><span class="keyword">function</span> <span class="params">()</span> {</span>
    <span class="keyword">var</span> div;

    <span class="keyword">return</span> <span class="function"><span class="keyword">function</span> <span class="params">()</span> {</span>
        <span class="keyword">if</span>(!div) {
            div = document.createElement(<span class="string">'div'</span>);
            div.innerHTML = <span class="string">'我是浮动窗'</span>;
            document.body.appendChild(div);
        }

        <span class="keyword">return</span> div;
    };
})();

<span class="keyword">var</span> layer1 = createLayer();
<span class="keyword">var</span> layer2 = createLayer();

console.log(layer1 === layer2); <span class="comment">// true</span>
</pre></td></tr></table></figure>

<p>上面的代码把生成单例和创建悬浮窗的职责合在了一起，这个两个方法可以独立变化而不相互影响，那么遵守单一职责应该这样写。</p>
<a id="more"></a>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
</pre></td><td class="code"><pre><span class="keyword">var</span> getSingle = <span class="function"><span class="keyword">function</span> <span class="params">(fn)</span> {</span>
    <span class="keyword">var</span> rst;

    <span class="keyword">return</span> <span class="function"><span class="keyword">function</span> <span class="params">()</span> {</span>
        <span class="keyword">return</span> rst || (rst = fn.apply(<span class="keyword">this</span>, <span class="built_in">arguments</span>));
    };
};

<span class="keyword">var</span> createLayer = <span class="function"><span class="keyword">function</span> <span class="params">()</span> {</span>
    <span class="keyword">var</span> div = document.createElement(<span class="string">'div'</span>);

    div.innerHTML = <span class="string">'我是浮动窗'</span>;
    document.body.appendChild(div);

    <span class="keyword">return</span> div;
};

<span class="keyword">var</span> createIframe = <span class="function"><span class="keyword">function</span> <span class="params">()</span> {</span>
    <span class="keyword">var</span> iframe = document.createElement(<span class="string">'iframe'</span>);

    iframe.src = <span class="string">'http://g.cn'</span>;
    document.body.appendChild(iframe);

    <span class="keyword">return</span> iframe;
};


<span class="keyword">var</span> getLayer = getSingle(createLayer);
<span class="keyword">var</span> layer1 = getLayer();
<span class="keyword">var</span> layer2 = getLayer();

console.log(layer1 === layer2); <span class="comment">// true</span>


<span class="keyword">var</span> getIframe = getSingle(createIframe);
<span class="keyword">var</span> iframe1 = getIframe();
<span class="keyword">var</span> iframe2 = getIframe();

console.log(getIframe === getIframe); <span class="comment">// true</span>
</pre></td></tr></table></figure>

<h2 id="何时应该分离职责">何时应该分离职责</h2>
<p>要明确的是，并不是所有的职责都应该分离。<br>一方面，如果随着需求的变化，有两个职责总是同时变化，那么不必分离它们，比如ajax的时候，创建xhr对象和发送xhr对象的请求几乎总是一起的，那么没有必要分开。</p>
<h2 id="违反单一职责原则">违反单一职责原则</h2>
<p>一方面我们受设计原则的指导，另一方面我们未必要在任何时候都一成不变的遵守原则而。<br>在实际开发中，因为种种原因违反原则的情况并不少见，例如jquery的attr方法，jquery的attr方法是一个很庞大的方法，既负责赋值，又负责取值，这对维护者来说会带来一定的困难，但对使用jquery的用户来说，却简化了使用。<br>在这方面，没有标准答案。</p>
<h2 id="优缺点">优缺点</h2>
<p>优点是降低了单个类或对象的复杂度，方便了复用和测试，修改时也不会影响到其他职责。<br>缺点是增加了编写代码的复杂度，当我们按照职责把对象分解成更小的颗粒之后，实际上也增大了对象之间相互联系的难度。</p>
]]></content>
    <summary type="html">
    <![CDATA[<h2 id="定义">定义</h2>
<p>如果我们有两个动机去改写一个方法，那么这个方法就具有两个职责。<br>每个职责都是变化的一个轴线，如果一个方法承担了过多的职责，那么在需求变化的过程中，需要改写这个方法的可能性就越大。<br>因此，单一职责(SRP)原则体现为：一个对象（方法）只做一件事。</p>
<h2 id="例子">例子</h2>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
</pre></td><td class="code"><pre><span class="keyword">var</span> createLayer = (<span class="function"><span class="keyword">function</span> <span class="params">()</span> {</span>
    <span class="keyword">var</span> div;

    <span class="keyword">return</span> <span class="function"><span class="keyword">function</span> <span class="params">()</span> {</span>
        <span class="keyword">if</span>(!div) {
            div = document.createElement(<span class="string">'div'</span>);
            div.innerHTML = <span class="string">'我是浮动窗'</span>;
            document.body.appendChild(div);
        }

        <span class="keyword">return</span> div;
    };
})();

<span class="keyword">var</span> layer1 = createLayer();
<span class="keyword">var</span> layer2 = createLayer();

console.log(layer1 === layer2); <span class="comment">// true</span>
</pre></td></tr></table></figure>

<p>上面的代码把生成单例和创建悬浮窗的职责合在了一起，这个两个方法可以独立变化而不相互影响，那么遵守单一职责应该这样写。</p>
]]>
    
    </summary>
    
      <category term="javascript" scheme="http://think2011.github.io/tags/javascript/"/>
    
      <category term="设计模式" scheme="http://think2011.github.io/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
      <category term="实战" scheme="http://think2011.github.io/tags/%E5%AE%9E%E6%88%98/"/>
    
      <category term="笔记" scheme="http://think2011.github.io/categories/%E7%AC%94%E8%AE%B0/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[再一次，javascript设计模式与开发实践-适配器模式]]></title>
    <link href="http://think2011.github.io/2015/07/15/design%20pattern%20in%20action/%E9%80%82%E9%85%8D%E5%99%A8%E6%A8%A1%E5%BC%8F/"/>
    <id>http://think2011.github.io/2015/07/15/design pattern in action/适配器模式/</id>
    <published>2015-07-14T16:09:11.000Z</published>
    <updated>2015-07-14T16:21:22.000Z</updated>
    <content type="html"><![CDATA[<h2 id="简述">简述</h2>
<blockquote>
<p>使接口保持一致</p>
</blockquote>
<p>在火车站、机场有临时的手机充电处，那里的数据线比较特别，一头有供各种手机用的接头，另一头是标准的USB接口，这种属于适配器模式。</p>
<h2 id="使用场景">使用场景</h2>
<ul>
<li>多个不同的数据接口</li>
<li>..</li>
</ul>
<h2 id="案例">案例</h2>
<p>渲染地图的API来自不同的提供，那么使用适配器模式来使API保持一致。</p>
<a id="more"></a>
<figure class="highlight js"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
</pre></td><td class="code"><pre><span class="keyword">var</span> googleMap = {
    show: <span class="function"><span class="keyword">function</span> <span class="params">()</span> {</span>
        console.log(<span class="string">'渲染谷歌地图'</span>);
    }
};

<span class="keyword">var</span> baiduMap = {
    display: <span class="function"><span class="keyword">function</span> <span class="params">()</span> {</span>
        console.log(<span class="string">'渲染百度地图'</span>);
    }
};

<span class="keyword">var</span> baiduMapAdapter = {
    show: <span class="function"><span class="keyword">function</span> <span class="params">()</span> {</span>
        <span class="keyword">return</span> baiduMap.display(<span class="built_in">arguments</span>);
    }
};

<span class="keyword">var</span> renderMap = <span class="function"><span class="keyword">function</span> <span class="params">(map)</span> {</span>
    map.show();
};

renderMap(googleMap);
renderMap(baiduMapAdapter);
</pre></td></tr></table></figure>]]></content>
    <summary type="html">
    <![CDATA[<h2 id="简述">简述</h2>
<blockquote>
<p>使接口保持一致</p>
</blockquote>
<p>在火车站、机场有临时的手机充电处，那里的数据线比较特别，一头有供各种手机用的接头，另一头是标准的USB接口，这种属于适配器模式。</p>
<h2 id="使用场景">使用场景</h2>
<ul>
<li>多个不同的数据接口</li>
<li>..</li>
</ul>
<h2 id="案例">案例</h2>
<p>渲染地图的API来自不同的提供，那么使用适配器模式来使API保持一致。</p>
]]>
    
    </summary>
    
      <category term="javascript" scheme="http://think2011.github.io/tags/javascript/"/>
    
      <category term="设计模式" scheme="http://think2011.github.io/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
      <category term="实战" scheme="http://think2011.github.io/tags/%E5%AE%9E%E6%88%98/"/>
    
      <category term="笔记" scheme="http://think2011.github.io/categories/%E7%AC%94%E8%AE%B0/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[再一次，javascript设计模式与开发实践-状态模式]]></title>
    <link href="http://think2011.github.io/2015/07/14/design%20pattern%20in%20action/%E7%8A%B6%E6%80%81%E6%A8%A1%E5%BC%8F/"/>
    <id>http://think2011.github.io/2015/07/14/design pattern in action/状态模式/</id>
    <published>2015-07-14T15:31:02.000Z</published>
    <updated>2015-07-14T15:52:08.000Z</updated>
    <content type="html"><![CDATA[<h2 id="简述">简述</h2>
<blockquote>
<p>允许一个对象在其内部状态改变时改变它的行为，对象看起来似乎修改了它的类。</p>
</blockquote>
<p>酒店的台灯开关顺序通常是：关灯 → 弱等 → 强灯 → 关灯，这这种行为就是状态。</p>
<h2 id="使用场景">使用场景</h2>
<ul>
<li>文件状态</li>
<li>角色动作</li>
<li>..</li>
</ul>
<h2 id="案例">案例</h2>
<p>如上台灯的状态行为，用多层if可以很快的编写代码，但假如新设计的台灯又多了一种状态呢？<br>随着情况越来越多，显然if的方式会违反开发-封闭原则，后续维护将变得复杂。<br>状态模式能够很好的解决这种问题。</p>
<a id="more"></a>
<figure class="highlight js"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
</pre></td><td class="code"><pre><span class="keyword">var</span> Light = <span class="function"><span class="keyword">function</span> <span class="params">()</span> {</span>
    <span class="keyword">this</span>.currState = FSM.off;
    <span class="keyword">this</span>.button    = <span class="literal">null</span>;
};

Light.prototype.init = <span class="function"><span class="keyword">function</span> <span class="params">()</span> {</span>
    <span class="keyword">var</span> button = document.createElement(<span class="string">'button'</span>),
        that   = <span class="keyword">this</span>;

    <span class="keyword">this</span>.button         = document.body.appendChild(button);
    <span class="keyword">this</span>.button.onclick = <span class="function"><span class="keyword">function</span> <span class="params">()</span> {</span>
        that.currState.buttonWasPressed.call(that);
    };

    FSM.off.buttonWasPressed.call(<span class="keyword">this</span>);
};

<span class="keyword">var</span> FSM = {
    off: {
        buttonWasPressed: <span class="function"><span class="keyword">function</span> <span class="params">()</span> {</span>
            console.log(<span class="string">'关灯'</span>);

            <span class="keyword">this</span>.button.innerHTML = <span class="string">'下一次按我是开灯'</span>;
            <span class="keyword">this</span>.currState        = FSM.on;
        }
    },

    on: {
        buttonWasPressed: <span class="function"><span class="keyword">function</span> <span class="params">()</span> {</span>
            console.log(<span class="string">'开灯'</span>);

            <span class="keyword">this</span>.button.innerHTML = <span class="string">'下一次按我是关灯'</span>;
            <span class="keyword">this</span>.currState        = FSM.off;
        }
    }
};

<span class="keyword">var</span> light = <span class="keyword">new</span> Light();
light.init();
</pre></td></tr></table></figure>]]></content>
    <summary type="html">
    <![CDATA[<h2 id="简述">简述</h2>
<blockquote>
<p>允许一个对象在其内部状态改变时改变它的行为，对象看起来似乎修改了它的类。</p>
</blockquote>
<p>酒店的台灯开关顺序通常是：关灯 → 弱等 → 强灯 → 关灯，这这种行为就是状态。</p>
<h2 id="使用场景">使用场景</h2>
<ul>
<li>文件状态</li>
<li>角色动作</li>
<li>..</li>
</ul>
<h2 id="案例">案例</h2>
<p>如上台灯的状态行为，用多层if可以很快的编写代码，但假如新设计的台灯又多了一种状态呢？<br>随着情况越来越多，显然if的方式会违反开发-封闭原则，后续维护将变得复杂。<br>状态模式能够很好的解决这种问题。</p>
]]>
    
    </summary>
    
      <category term="javascript" scheme="http://think2011.github.io/tags/javascript/"/>
    
      <category term="设计模式" scheme="http://think2011.github.io/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
      <category term="实战" scheme="http://think2011.github.io/tags/%E5%AE%9E%E6%88%98/"/>
    
      <category term="笔记" scheme="http://think2011.github.io/categories/%E7%AC%94%E8%AE%B0/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[再一次，javascript设计模式与开发实践-装饰者模式]]></title>
    <link href="http://think2011.github.io/2015/07/08/design%20pattern%20in%20action/%E8%A3%85%E9%A5%B0%E8%80%85%E6%A8%A1%E5%BC%8F/"/>
    <id>http://think2011.github.io/2015/07/08/design pattern in action/装饰者模式/</id>
    <published>2015-07-08T14:06:23.000Z</published>
    <updated>2015-07-08T14:14:21.000Z</updated>
    <content type="html"><![CDATA[<h2 id="简述">简述</h2>
<blockquote>
<p>在不改变对象自身的基础上，在程序运行期间给对象动态的添加功能。</p>
</blockquote>
<p>很多时候我们不想去碰原函数，也许原函数是其他同事的，也可能是一个很古老的项目，现在可以通过装饰者模式在不改变原函数的情况下给函数增加功能。</p>
<h2 id="使用场景">使用场景</h2>
<ul>
<li>统计</li>
<li>表单验证</li>
<li>..</li>
</ul>
<h2 id="案例">案例</h2>
<p>在项目开发中难免要加上很多统计代码，这些统计代码与业务代码并没有多大关系，那么使用装饰者模式再好不过了。</p>
<a id="more"></a>
<figure class="highlight js"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
</pre></td><td class="code"><pre><span class="built_in">Function</span>.prototype.after = <span class="function"><span class="keyword">function</span> <span class="params">(fn)</span> {</span>
    <span class="keyword">var</span> that = <span class="keyword">this</span>;

    <span class="keyword">return</span> <span class="function"><span class="keyword">function</span> <span class="params">()</span> {</span>
        <span class="keyword">var</span> ret = that.apply(<span class="keyword">this</span>, <span class="built_in">arguments</span>);

        fn.apply(<span class="keyword">this</span>, <span class="built_in">arguments</span>);

        <span class="keyword">return</span> ret;
    };
};

<span class="built_in">Function</span>.prototype.before = <span class="function"><span class="keyword">function</span> <span class="params">(fn)</span> {</span>
    <span class="keyword">var</span> that = <span class="keyword">this</span>;

    <span class="keyword">return</span> <span class="function"><span class="keyword">function</span> <span class="params">()</span> {</span>
        fn.apply(<span class="keyword">this</span>, <span class="built_in">arguments</span>);

        <span class="keyword">return</span> that.apply(<span class="keyword">this</span>, <span class="built_in">arguments</span>);
    };
};

<span class="keyword">var</span> showLogin = <span class="function"><span class="keyword">function</span> <span class="params">()</span> {</span>
    console.log(<span class="string">'打开登陆框'</span>);
};

showLogin = showLogin.after(<span class="function"><span class="keyword">function</span> <span class="params">()</span> {</span>
    console.log(<span class="string">'上报登录统计'</span>);
});

showLogin();
</pre></td></tr></table></figure>]]></content>
    <summary type="html">
    <![CDATA[<h2 id="简述">简述</h2>
<blockquote>
<p>在不改变对象自身的基础上，在程序运行期间给对象动态的添加功能。</p>
</blockquote>
<p>很多时候我们不想去碰原函数，也许原函数是其他同事的，也可能是一个很古老的项目，现在可以通过装饰者模式在不改变原函数的情况下给函数增加功能。</p>
<h2 id="使用场景">使用场景</h2>
<ul>
<li>统计</li>
<li>表单验证</li>
<li>..</li>
</ul>
<h2 id="案例">案例</h2>
<p>在项目开发中难免要加上很多统计代码，这些统计代码与业务代码并没有多大关系，那么使用装饰者模式再好不过了。</p>
]]>
    
    </summary>
    
      <category term="javascript" scheme="http://think2011.github.io/tags/javascript/"/>
    
      <category term="设计模式" scheme="http://think2011.github.io/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
      <category term="实战" scheme="http://think2011.github.io/tags/%E5%AE%9E%E6%88%98/"/>
    
      <category term="笔记" scheme="http://think2011.github.io/categories/%E7%AC%94%E8%AE%B0/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[再一次，javascript设计模式与开发实践-中介者模式]]></title>
    <link href="http://think2011.github.io/2015/07/06/design%20pattern%20in%20action/%E4%B8%AD%E4%BB%8B%E8%80%85%E6%A8%A1%E5%BC%8F/"/>
    <id>http://think2011.github.io/2015/07/06/design pattern in action/中介者模式/</id>
    <published>2015-07-06T15:58:48.000Z</published>
    <updated>2015-07-06T16:38:47.000Z</updated>
    <content type="html"><![CDATA[<h2 id="简述">简述</h2>
<blockquote>
<p>解除对象与对象之间的紧耦合关系。</p>
</blockquote>
<p>当飞机想要降落时，会通知指挥塔，指挥塔安排降落，而不必和其他飞机通信，来保证安全。<br>购买足球彩票，只需要把钱交给博彩公司，博彩公司负责收钱和发钱，而不必与其他人交换信息。</p>
<h2 id="使用场景">使用场景</h2>
<ul>
<li>游戏</li>
<li>购物订单</li>
<li>..</li>
</ul>
<h2 id="案例">案例</h2>
<p>如果要写一个购物订单程序，使用中介者模式是个很好的方式。</p>
<a id="more"></a>
<figure class="highlight html"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
</pre></td><td class="code"><pre><span class="tag">&lt;<span class="title">body</span>&gt;</span>
	选择颜色：
	<span class="tag">&lt;<span class="title">select</span> <span class="attribute">id</span>=<span class="value">"colorSelect"</span>&gt;</span>
		<span class="tag">&lt;<span class="title">option</span> <span class="attribute">value</span>=<span class="value">""</span>&gt;</span>请选择<span class="tag">&lt;/<span class="title">option</span>&gt;</span>
		<span class="tag">&lt;<span class="title">option</span> <span class="attribute">value</span>=<span class="value">"蓝色"</span>&gt;</span>蓝色<span class="tag">&lt;/<span class="title">option</span>&gt;</span>
		<span class="tag">&lt;<span class="title">option</span> <span class="attribute">value</span>=<span class="value">"红色"</span>&gt;</span>红色<span class="tag">&lt;/<span class="title">option</span>&gt;</span>
	<span class="tag">&lt;/<span class="title">select</span>&gt;</span>

	选择内存：
	<span class="tag">&lt;<span class="title">select</span> <span class="attribute">id</span>=<span class="value">"memorySelect"</span>&gt;</span>
		<span class="tag">&lt;<span class="title">option</span> <span class="attribute">value</span>=<span class="value">""</span>&gt;</span>请选择<span class="tag">&lt;/<span class="title">option</span>&gt;</span>
		<span class="tag">&lt;<span class="title">option</span> <span class="attribute">value</span>=<span class="value">"32G"</span>&gt;</span>64G<span class="tag">&lt;/<span class="title">option</span>&gt;</span>
		<span class="tag">&lt;<span class="title">option</span> <span class="attribute">value</span>=<span class="value">"64G"</span>&gt;</span>32G<span class="tag">&lt;/<span class="title">option</span>&gt;</span>
	<span class="tag">&lt;/<span class="title">select</span>&gt;</span>
	<span class="tag">&lt;<span class="title">hr</span>&gt;</span>	
	您选择了颜色：<span class="tag">&lt;<span class="title">div</span> <span class="attribute">id</span>=<span class="value">"colorInfo"</span>&gt;</span><span class="tag">&lt;/<span class="title">div</span>&gt;</span>
	您选择了内存：<span class="tag">&lt;<span class="title">div</span> <span class="attribute">id</span>=<span class="value">"memoryInfo"</span>&gt;</span><span class="tag">&lt;/<span class="title">div</span>&gt;</span>
<span class="tag">&lt;/<span class="title">body</span>&gt;</span>
</pre></td></tr></table></figure>

<figure class="highlight js"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
</pre></td><td class="code"><pre><span class="keyword">var</span> mediator = (<span class="function"><span class="keyword">function</span><span class="params">()</span> {</span>
	<span class="keyword">var</span> colorSelect = document.querySelector(<span class="string">'#colorSelect'</span>),
		memorySelect = document.querySelector(<span class="string">'#memorySelect'</span>),
		colorInfo = document.querySelector(<span class="string">'#colorInfo'</span>),
		memoryInfo = document.querySelector(<span class="string">'#memoryInfo'</span>);

	<span class="keyword">return</span> {
		changed: <span class="function"><span class="keyword">function</span><span class="params">(obj)</span> {</span>
			<span class="keyword">var</span> color = colorSelect.value,
				memory = memorySelect.value;

			<span class="keyword">if</span> (obj === colorSelect) {
				colorInfo.innerHTML = color;
			} <span class="keyword">else</span> <span class="keyword">if</span> (obj === memorySelect) {
				memoryInfo.innerHTML = memory;
			}
		}
	};
})();

colorSelect.onchange = <span class="function"><span class="keyword">function</span><span class="params">()</span> {</span>
	mediator.changed(<span class="keyword">this</span>);
};

memorySelect.onchange = <span class="function"><span class="keyword">function</span><span class="params">()</span> {</span>
	mediator.changed(<span class="keyword">this</span>);
};
</pre></td></tr></table></figure>]]></content>
    <summary type="html">
    <![CDATA[<h2 id="简述">简述</h2>
<blockquote>
<p>解除对象与对象之间的紧耦合关系。</p>
</blockquote>
<p>当飞机想要降落时，会通知指挥塔，指挥塔安排降落，而不必和其他飞机通信，来保证安全。<br>购买足球彩票，只需要把钱交给博彩公司，博彩公司负责收钱和发钱，而不必与其他人交换信息。</p>
<h2 id="使用场景">使用场景</h2>
<ul>
<li>游戏</li>
<li>购物订单</li>
<li>..</li>
</ul>
<h2 id="案例">案例</h2>
<p>如果要写一个购物订单程序，使用中介者模式是个很好的方式。</p>
]]>
    
    </summary>
    
      <category term="javascript" scheme="http://think2011.github.io/tags/javascript/"/>
    
      <category term="设计模式" scheme="http://think2011.github.io/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
      <category term="实战" scheme="http://think2011.github.io/tags/%E5%AE%9E%E6%88%98/"/>
    
      <category term="笔记" scheme="http://think2011.github.io/categories/%E7%AC%94%E8%AE%B0/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[再一次，javascript设计模式与开发实践-职责链模式]]></title>
    <link href="http://think2011.github.io/2015/07/05/design%20pattern%20in%20action/%E8%81%8C%E8%B4%A3%E9%93%BE%E6%A8%A1%E5%BC%8F/"/>
    <id>http://think2011.github.io/2015/07/05/design pattern in action/职责链模式/</id>
    <published>2015-07-05T03:44:22.000Z</published>
    <updated>2015-07-05T05:31:41.000Z</updated>
    <content type="html"><![CDATA[<h2 id="简述">简述</h2>
<blockquote>
<p>使多个对象都有机会处理请求，从而避免请求的发送者和接收者之间的耦合关系，这些对象连成一条链，并沿着链条传递该请求，直到有对象处理它为止。</p>
</blockquote>
<p>例如高峰期搭公交，上车后没办法刷卡，只好把羊城通往前传递，经过几个人传递，最终才刷到卡。<br>例如上课时传纸条，同学间帮忙传递，最终送到要送到的人手上。</p>
<h2 id="使用场景">使用场景</h2>
<ul>
<li>兼容判断</li>
<li>订单优惠</li>
<li>..</li>
</ul>
<h2 id="案例">案例</h2>
<p>我们负责的电商网站购买有一些优惠。</p>
<ul>
<li>支付500元定金得到100元优惠券。</li>
<li>支付200元定金得到50元优惠券。</li>
<li>不支付定金，无优惠。</li>
</ul>
<a id="more"></a>
<p>为了不写出大量if判断，可以采用职责链模式。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
</pre></td><td class="code"><pre><span class="built_in">Function</span>.prototype.after = <span class="function"><span class="keyword">function</span> <span class="params">(fn)</span> {</span>
    <span class="keyword">var</span> that = <span class="keyword">this</span>;

    <span class="keyword">return</span> <span class="function"><span class="keyword">function</span> <span class="params">()</span> {</span>
        <span class="keyword">var</span> ret = that.apply(<span class="keyword">this</span>, <span class="built_in">arguments</span>);

        <span class="keyword">if</span> (ret === <span class="string">'nextSuccessor'</span>) {
            <span class="keyword">return</span> fn.apply(<span class="keyword">this</span>, <span class="built_in">arguments</span>);
        }

        <span class="keyword">return</span> ret;
    };
};

<span class="keyword">var</span> order500 = <span class="function"><span class="keyword">function</span><span class="params">(type, pay, stock)</span> {</span>
    <span class="keyword">if</span>(type === <span class="number">1</span> && pay) {
        console.log(<span class="string">'500定金，赠送100优惠券'</span>);
    } <span class="keyword">else</span> {
        <span class="keyword">return</span> <span class="string">'nextSuccessor'</span>;
    }
};

<span class="keyword">var</span> order200 = <span class="function"><span class="keyword">function</span><span class="params">(type, pay, stock)</span> {</span>
    <span class="keyword">if</span>(type === <span class="number">2</span> && pay) {
        console.log(<span class="string">'200定金，赠送50优惠券'</span>);
    } <span class="keyword">else</span> {
        <span class="keyword">return</span> <span class="string">'nextSuccessor'</span>;
    }
};

<span class="keyword">var</span> orderNormal = <span class="function"><span class="keyword">function</span><span class="params">(type, pay, stock)</span> {</span>
    <span class="keyword">if</span>(stock &gt; <span class="number">0</span>) {
        console.log(<span class="string">'普通购买，无优惠券'</span>);
    } <span class="keyword">else</span> {
        console.log(<span class="string">'库存不足'</span>);
    }
};

<span class="keyword">var</span> order = order500.after(order200).after(orderNormal);

order(<span class="number">1</span>, <span class="literal">true</span>, <span class="number">500</span>);
order(<span class="number">2</span>, <span class="literal">true</span>, <span class="number">200</span>);
order(<span class="number">1</span>, <span class="literal">false</span>, <span class="number">500</span>);
</pre></td></tr></table></figure>]]></content>
    <summary type="html">
    <![CDATA[<h2 id="简述">简述</h2>
<blockquote>
<p>使多个对象都有机会处理请求，从而避免请求的发送者和接收者之间的耦合关系，这些对象连成一条链，并沿着链条传递该请求，直到有对象处理它为止。</p>
</blockquote>
<p>例如高峰期搭公交，上车后没办法刷卡，只好把羊城通往前传递，经过几个人传递，最终才刷到卡。<br>例如上课时传纸条，同学间帮忙传递，最终送到要送到的人手上。</p>
<h2 id="使用场景">使用场景</h2>
<ul>
<li>兼容判断</li>
<li>订单优惠</li>
<li>..</li>
</ul>
<h2 id="案例">案例</h2>
<p>我们负责的电商网站购买有一些优惠。</p>
<ul>
<li>支付500元定金得到100元优惠券。</li>
<li>支付200元定金得到50元优惠券。</li>
<li>不支付定金，无优惠。</li>
</ul>
]]>
    
    </summary>
    
      <category term="javascript" scheme="http://think2011.github.io/tags/javascript/"/>
    
      <category term="设计模式" scheme="http://think2011.github.io/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
      <category term="实战" scheme="http://think2011.github.io/tags/%E5%AE%9E%E6%88%98/"/>
    
      <category term="笔记" scheme="http://think2011.github.io/categories/%E7%AC%94%E8%AE%B0/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[再一次，javascript设计模式与开发实践-享元模式]]></title>
    <link href="http://think2011.github.io/2015/07/05/design%20pattern%20in%20action/%E4%BA%AB%E5%85%83%E6%A8%A1%E5%BC%8F/"/>
    <id>http://think2011.github.io/2015/07/05/design pattern in action/享元模式/</id>
    <published>2015-07-04T17:14:02.000Z</published>
    <updated>2015-07-04T18:57:01.000Z</updated>
    <content type="html"><![CDATA[<h2 id="简述">简述</h2>
<blockquote>
<p>一种优化性能的模式，享元的核心是运用共享技术来有效支持大量细粒度的对象。</p>
</blockquote>
<p>假设服装工厂有50种款式的衣服，为了推销产品工厂决定请模特来穿服装拍摄，在现实中不会请50名模特来试穿，所以在程序中享元模式指的就是这种情况。</p>
<h2 id="使用场景">使用场景</h2>
<ul>
<li>地图图钉</li>
<li>标签页</li>
<li>..</li>
</ul>
<h2 id="案例">案例</h2>
<a id="more"></a>
<p>假如我们在设计一个标签页功能，每个标签都需要载入iframe，没有必要每张标签都创建一个iframe元素，那么可以使用享元模式。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
</pre></td><td class="code"><pre><span class="keyword">var</span> objPoolFactory = <span class="function"><span class="keyword">function</span> <span class="params">(createObjFn)</span> {</span>
    <span class="keyword">var</span> objPool = [];

    <span class="keyword">return</span> {
        create : <span class="function"><span class="keyword">function</span> <span class="params">()</span> {</span>
            <span class="keyword">return</span> objPool.length ? objPool.shift() : createObjFn.apply(<span class="keyword">this</span>, <span class="built_in">arguments</span>);
        },
        recover: <span class="function"><span class="keyword">function</span> <span class="params">(obj)</span> {</span>
            objPool.push(obj);
        }
    }
};

<span class="keyword">var</span> iframeFactory = objPoolFactory(<span class="function"><span class="keyword">function</span><span class="params">()</span> {</span>
    <span class="keyword">var</span> iframe = document.createElement(<span class="string">'iframe'</span>);
    document.body.appendChild(iframe);

    iframe.onload = <span class="function"><span class="keyword">function</span><span class="params">()</span> {</span>
        iframe.onload = <span class="literal">null</span>;
        iframeFactory.recover(iframe);
    };

    <span class="keyword">return</span> iframe;
});

<span class="keyword">var</span> iframe1 = iframeFactory.create();
iframe1.src = <span class="string">'http://baidu.com'</span>;

<span class="keyword">var</span> iframe2 = iframeFactory.create();
iframe2.src = <span class="string">'http://google.com'</span>;

setTimeout(<span class="function"><span class="keyword">function</span> <span class="params">()</span> {</span>
    <span class="keyword">var</span> iframe3 = iframeFactory.create();
    iframe3.src = <span class="string">'http://baidu.com'</span>;
}, <span class="number">3000</span>);
</pre></td></tr></table></figure>
]]></content>
    <summary type="html">
    <![CDATA[<h2 id="简述">简述</h2>
<blockquote>
<p>一种优化性能的模式，享元的核心是运用共享技术来有效支持大量细粒度的对象。</p>
</blockquote>
<p>假设服装工厂有50种款式的衣服，为了推销产品工厂决定请模特来穿服装拍摄，在现实中不会请50名模特来试穿，所以在程序中享元模式指的就是这种情况。</p>
<h2 id="使用场景">使用场景</h2>
<ul>
<li>地图图钉</li>
<li>标签页</li>
<li>..</li>
</ul>
<h2 id="案例">案例</h2>
]]>
    
    </summary>
    
      <category term="javascript" scheme="http://think2011.github.io/tags/javascript/"/>
    
      <category term="设计模式" scheme="http://think2011.github.io/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
      <category term="实战" scheme="http://think2011.github.io/tags/%E5%AE%9E%E6%88%98/"/>
    
      <category term="笔记" scheme="http://think2011.github.io/categories/%E7%AC%94%E8%AE%B0/"/>
    
  </entry>
  
</feed>
